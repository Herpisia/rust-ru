## Пример использования структур

Для понимания, где мы могли бы использовать структуры, мы напишем программу, которая будет рассчитывать площадь прямоугольника. Мы начнём с создания переменных, а потом постепенно напишем код, который будет использовать структуры.

Создадим проект программы с помощью Cargo с именем *rectangles*, которая будет получать на вход длину и ширину прямоугольника в пикселях и будет рассчитывать площадь прямоугольника. Листинг 5-8 показывает короткую программу с одним из способов сделать именно это, код в файле проекта *src/main.rs* .

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let length1 = 50;
    let width1 = 30;

    println!(
        "The area of the rectangle is {} square pixels.",
        area(length1, width1)
    );
}

fn area(length: u32, width: u32) -> u32 {
    length * width
}
```

<span class="caption">Пример 5-8: Расчёт площади треугольника с помощью отдельных переменных ширины и высоты</span>

Теперь, проверим её работу `cargo run`:

```text
The area of the rectangle is 1500 square pixels.
```

Хотя код листинга 5-8 работает и рассчитывает площадь прямоугольника вызывая функцию `area` для каждого изменения, мы можем улучшить программу. Переменные длина и ширина связаны логически, так как они совместно описывают параметры прямоугольника.

Проблема данного метода очевидна из сигнатуры `area`:

```rust,ignore
fn area(length: u32, width: u32) -> u32 {
```

Функция `area` должна рассчитывать площадь одного прямоугольника, но у функции описано два параметра. Эти параметры связаны, но это никак не отражено в коде программы. Код был бы более очевидным и управляемым, если бы переменные ширины и длины были сгруппированы вместе. Мы уже знаем один способ группировки переменных из раздела  “Тип кортеж” главы 3, используя кортежи.

### Изменение с помощью кортежей

Листинг 5-9 это другая версия программы, используемая кортежи.

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let rect1 = (30, 50);

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -> u32 {
    dimensions.0 * dimensions.1
}
```

<span class="caption">Листинг 5-9: Указание ширины и высоты прямоугольника с помощью кортежа</span>

С одной стороны, эта программа стала лучше. Кортежи позволяют лучше структурировать код, теперь мы передаём один аргумент. Но с другой стороны данная версия менее понятная: кортежи не имеют имён для элементов, так что расчёт стал более запутанным из-за необходимости индексирования частей кортежа.

Если мы перепутаем местами ширину с высотой при расчёте площади, то это не имеет значения. Но если нужно нарисовать прямоугольник на экране, то это уже будет иметь значение! Придётся помнить, что ширина  `width` находится в кортеже с индексом `0`, а высота `height` с индексом `1`. Если кто-то другой поработал бы с кодом, ему бы пришлось разобраться в этом и также помнить про порядок. Легко забыть и перепутать эти значения и это вызовет ошибки, потому что данный код не передаёт наши намерения.

### Изменения для структур: добавим больше смысла

Мы пользуемся структурами, добавляем с их помощью смысл, помечая данные. Мы можем переделать используемый кортеж в тип данных с именем всей сущности и названиями её части, как показано в листинге 5-10.

<span class="filename">Файл: src/main.rs</span>

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&rect1)
    );
}

fn area(rectangle: &Rectangle) -> u32 {
    rectangle.width * rectangle.height
}
```

<span class="caption">Пример 5-10: Определение структуры <code>Rectangle</code></span>

Здесь мы определили структуру, дали ей имя `Rectangle`. Внутри фигурных скобок определили поля как `width` и `height`, оба типа `u32`. Затем в `main` создали конкретный экземпляр `Rectangle` с шириной в 30 и высотой в 50 единиц.

Наша функция `area` теперь определена с одним параметром названным `rectangle`, чей тип является экземпляром неизменяемой, заимствованной структуры `Rectangle`. Как упоминалось в главе 4, необходимо заимствовать структуру, а не передавать её во владение. Таким образом функция `main` сохраняет её в собственности и продолжает использоваться `rect1`, что является причиной использования `&` в сигнатуре в месте её вызова.

Функция `area` имеет доступ к полям `width` и `height` экземпляра `Rectangle`. Сигнатура нашей функции для `area` теперь точно говорит, что мы имели ввиду: посчитать площадь `Rectangle` используя поля `width` и `height`. Это передаёт то, что ширина и высота относятся друг к другу и это сделано назначением понятных имён, вместо использования значений индексов кортежа `0` и `1`. Это плюс к ясности.

### Добавление полезной функциональности используя выводимые типажи

Было бы не плохо иметь возможность печатать экземпляр `Rectangle` во время отладки программы и видеть значения всех полей. Листинг 5-11 использует макрос `println!`, который мы уже использовали в предыдущих главах. Тем не менее, это не работает.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!("rect1 is {}", rect1);
}
```

<span class="caption">Листинг 5-11: Попытка печатать экземпляр <code>Rectangle</code></span>

При компиляции этого кода мы получаем ошибку с сообщением:

```text
error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
```

Макрос `println!` умеет делать разные виды форматирования по умолчанию, фигурные скобки `println!` используются для форматирования, известного как типаж `Display`: который предназначен для использования пользователем. Примитивные типы изученные ранее, по умолчанию реализуют `Display`, потому что есть только один способ отобразить число `1` или любой другой примитивный тип пользователю. Но для структур у которых `println!` должен форматировать способ вывода данных, это является менее очевидным, потому что есть гораздо больше возможностей для отображения: Вы хотите запятые или нет? Вы хотите печатать фигурные скобки? Нужно ли показать все поля? Из-за этой неоднозначности Rust не пытается  угадать, что нам нужно и структуры не имеют готовой реализации типажа `Display`.

Продолжив чтение текста ошибки, мы найдём полезное замечание:

```text
= help: the trait `std::fmt::Display` is not implemented for `Rectangle`
= note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
```

Давайте попробуем! Вызов макроса `println!` теперь будет выглядеть так `println!("rect1 is {:?}", rect1);`. Ввод спецификатора `:?` внутри фигурных скобок говорит макросу `println!`, что мы хотим использовать формат вывода называемый `Debug`. Типаж `Debug` позволяет печатать структуру способом, удобным для разработчиков, чтобы видеть значение во время отладки кода.

Скомпилируем код с этими изменениями. Упс! Мы всё ещё получаем ошибку:

```text
error[E0277]: `Rectangle` doesn't implement `std::fmt::Debug`
```

Снова компилятор даёт нам полезное замечание:

```text
= help: the trait `std::fmt::Debug` is not implemented for `Rectangle`
= note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug`
```

Rust *НЕ* включает функциональность для печати отладочной информации, мы должны явно включить эту функциональность для нашей структуры. Чтобы это сделать, добавляем аннотацию `#[derive(Debug)]` сразу перед определением структуры как показано в листинге 5-12.

<span class="filename">Файл: src/main.rs</span>

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!("rect1 is {:?}", rect1);
}
```

<span class="caption">Листинг 5-12: Добавление аннотации для реализации типажа  <code>Debug</code> и печати экземпляра <code>Rectangle</code> с отладочным форматированием</span>

Теперь при запуске программы не получаем ошибок и увидим следующий вывод:

```text
rect1 is Rectangle { width: 30, height: 50 }
```

Отлично! Это не делает вывод приятнее, но показывает значения всех полей экземпляра, которые определённо помогут при отладке. Когда у нас структуры больше, то полезно иметь более простой для чтения вывод; в таком случае можно использовать код `{:#?}` вместо ` {:?}` в строке макроса `println!`. При использовании стиля `{:#?}` в примере вывод будет выглядеть так:

```text
rect1 is Rectangle {
    width: 30,
    height: 50
}
```

Rust предоставляет несколько типажей для использования в аннотации `derive`, они умеют давать полезное поведение пользовательским типам. Эти типажи и их поведение перечислены в приложении C. Мы обсудим как реализовать данные типажи с пользовательским поведением, а также как создавать свои собственные типажи в главе 10.

Функция `area` является довольно специфичной: она считает только площадь прямоугольников. Было бы полезно привязать данное поведение как можно ближе к структуре `Rectangle`, потому что код не будет работать с любым другим типом. Давайте рассмотрим, как можно продолжить изменения этого кода превращая функцию `area` в *метод* `area`, определённый для типа `Rectangle`.
