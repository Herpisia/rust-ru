## Срезы

Другим типом данных, который не забирает во владение данные является *срез* (slice). Срез позволяет ссылаться на смежную последовательность элементов из коллекции, вместо полной коллекции.

Рассмотрим небольшую программную проблему: необходимо написать функцию, входным параметром которой является строка, а выходным значением функции является первое слово, которое будет найдено в этой строке. Если функция не находит пробелы, она возвращает полную строку.

Давайте подумаем над сигнатурой этой функции:

```rust,ignore
fn first_word(s: &String) -> ?
```

Функция `first_word` имеет входной параметр типа `&String`. Нам не нужно владение переменной, так что это нормально. Но что мы должны вернуть? На самом деле у нас нет способа выразить *часть* строки. Тем не менее, для решения задачи мы можем найти индекс конца слова в строке используя пробел. Попробуем сделать как на листинге 4-7:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:here}}
```

<span class="caption">Листинг 4-7: Пример функции <code>first_word</code>, которая возвращает значение индекса пробела внутри строкового параметра <code>String</code></span>

Для того, чтобы найти пробел в строке, мы превратим `String` в массив байт, используя метод `as_bytes` и пройдём по `String` элемент за элементом, проверяя является ли значение пробелом.

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:as_bytes}}
```

Далее, мы создаём <em>итератор</em> по массиву байт используя метод `iter`:

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:iter}}
```

Мы изучим итераторы более детально в Главе 13. Сейчас, достаточно понять, что метод `iter` при каждом вызове возвращает следующий элемент коллекции, а метод `enumerate` оборачивает результаты работы метода `iter` и возвращает каждый элемент упакованным в кортеж. Первый элемент этого кортежа возвращён из `enumerate` и является индексом, а второй элемент - ссылка на элемент коллекции которую предоставил метод `iter`. Такой способ перебора элементов массива является более удобным - не надо считать индекс самостоятельно.

Так как метод `enumerate` возвращает кортеж, мы можем использовать шаблон деструктуризации кортежа, как и везде в Rust. Так в цикле `for`, мы указываем шаблон `(i, &item)` который распакует значения кортежа в `i` для хранения индекса из кортежа и в `&item` который сразу же возьмёт по ссылке байт символа из кортежа. Мы используем `&` в шаблоне по причине того, что метод  `.iter().enumerate()` возвращает нам ссылку на элемент.

Внутри цикла `for`, ищем байт представляющий пробел используя синтаксис байт литерала. Если пробел найден, возвращается его позиция. Иначе, возвращается длина строки `s.len()`:

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:inside_for}}
```

Теперь у нас есть способ узнать индекс байта указывающего на конец первого слова в строке, но есть проблема. Мы возвращаем сам `usize`, но это число имеет значение только в контексте `&String`. Другими словами, поскольку это значение отдельное от `String`, то нет гарантии, что оно все ещё будет действительным в будущем. Рассмотрим программу из листинга 4-8, которая использует функцию `first_word` листинга 4-7.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-08/src/main.rs:here}}
```

<span class="caption">Listing 4-8: Сохранение результата вызова функции <code>first_word</code>, а затем изменение содержимого <code>String</code></span>

Данная программа компилируется без ошибок и будет успешно работать, даже после того как мы воспользуемся переменной `word` после вызова `s.clear()`. Так как значение `word` совсем не связано с состоянием переменной `s`, то `word` сохраняет своё значение `5` без изменений. Мы могли бы использовать `5` вместе с переменной `s` и попытаться извлечь первое слово из строки, но это приведёт к ошибке, потому что содержимое `s` изменилось после того как мы сохранили `5` в переменной `word` (стало пустой строкой в вызове `s.clear()`).

Необходимость беспокоиться о том, что индекс в переменной `word` не синхронизируется с данными в переменной  `s` является утомительной и подверженной ошибкам! Управление этими индексами становится ещё более хрупким, если мы напишем функцию `second_word`. Её сигнатура могла бы выглядеть так:

```rust,ignore
fn second_word(s: &String) -> (usize, usize) {
```

Теперь мы отслеживаем *начальный и конечный* индексы, у нас стало ещё больше значений, которые рассчитаны на основе данных о содержимом в определённом состоянии строки, но которые также совсем не привязаны к данному состоянию. Теперь есть уже три не связанные переменные, которые необходимо синхронизировать.

К счастью в Rust есть решение данной проблемы: строковые срезы.

### Строковые срезы

Строковый срез - это ссылка на часть строки `String` и он выглядит следующим образом:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-17-slice/src/main.rs:here}}
```

Эта инициализация похожа на создание ссылки на переменную `String`, но с дополнительным условием - указанием отрезка `[0..5]`. Вместо ссылки на всю `String`, срез ссылается на её часть.

Мы можем создавать срезы, используя диапазон в квадратных скобках указывая `[starting_index..ending_index]`, где `starting_index` означает первую позицию в срезе, а `ending_index` на единицу больше, чем последняя позиция. Во внутреннем представлении, срез хранит начальную позицию и длину среза, которая соответствует числу `ending_index` минус `starting_index`. Таким образом, в примере `let world = &s[6..11];`, переменная `world` будет срезом, который содержит ссылку на 7-ой байт в `s` со значением длины равным 5.

Рисунок 4-6 отображает это на диаграмме.

 <img alt="world containing a pointer to the 6th byte of String s and a length 5" src="img/trpl04-06.svg" class="">

<span class="caption">Рисунок 4-6: Строковый срез ссылается на часть <code>String</code></span>

Возможно использовать синтаксис диапазона `..` и другим способом. Если хочется начать с начального индекса (с нуля), то можно убрать число перед двоеточием. Другими словами, это эквивалентно:

```rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
```

Таким же образом, если срез включает последний байт строки `String`, можно убрать завершающее число. Это эквивалентно:

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
```

Также можно не указывать оба значения, чтобы получить срез всей строки. Это эквивалентно:

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
```

> Внимание: Индексы среза строк должны соответствовать границам UTF-8 символов. Если вы попытаетесь получить срез нарушая границы символа в котором больше одного байта, то вы получите ошибку времени исполнения. В рамках этой главы мы будем предполагать только ASCII кодировку. Более детальное обсуждение UTF-8 находится в секции ["Сохранение текста с кодировкой UTF-8 в строках"]<!--  --> Главы 8.

Давайте используем полученную информацию и перепишем метод `first_word` так, чтобы он возвращал срез. Для обозначения типа "срез строки" существует запись `&str`:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-18-first-word-slice/src/main.rs:here}}
```

Мы получаем индекс конца слова способом аналогичным тому, как мы это делали в листинге 4-7: ищем индекс первого вхождения пробела, когда пробел найден, возвращается строковый срез, используя начало строки в качестве начального индекса и индекс пробела в качестве конечного индекса среза.

Теперь, вызвав метод `first_word`, мы получим одно единственное значение, которое привязано к нижележащим данным. Значение, которое составлено из ссылки на начальную точку среза и количества элементов в срезе.

Аналогичным образом можно переписать и второй метод `second_word`:

```rust,ignore
fn second_word(s: &String) -> &str {
```

Теперь есть простое API, работу которого гораздо сложнее испортить, потому что компилятор обеспечивает нам то, что ссылки на `String` останутся действительными. Помните ошибку в программе листинга 4-8, когда мы получили индекс конца первого слова, но затем очистили строку, так что она стала недействительной? Тот код был логически некорректным, хотя не показывал никаких ошибок. Проблемы возникли бы позже, если бы мы попытались использовать индекс первого слова для пустой строки. Срезы делают невозможной данную ошибку и позволяют понять о наличии проблемы гораздо раньше. Так, использование версии метода `first_word` со срезом вернёт ошибку компиляции:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-19-slice-error/src/main.rs:here}}
```

Ошибка компиляции:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-19-slice-error/output.txt}}
```

Напомним вам правила заимствования: если у нас есть неизменяемая ссылка на что-либо, то нельзя взять изменяемую ссылку для этого чего-то. Так как методу `clear` требуется обрезать `String`, ему нужно получить изменяемую ссылку. Rust не позволяет это сделать и компиляции не проходит. Rust не только упростил использование нашего API, но и исключил целый класс ошибок во время компиляции!

#### Строковые литералы это срезы

Напомним, что мы говорили о строковых литералах, хранящихся внутри бинарного файла. Теперь, когда мы знаем чем являются срезы, мы правильно понимаем что такое строковые литералы:

```rust
let s = "Hello, world!";
```

Тип `s` здесь является `&str` срезом, указывающим на конкретное место в бинарном файле программы. Это также объясняет, почему строковый литерал является неизменяемым, потому что тип `&str` это неизменяемая ссылка.

#### Строковые срезы как параметры<a id="string-slices-as-parameters"/>

Знание о том, что можно брать срезы строковых литералов и `String` строк приводит к ещё одному улучшению метода `first_word`, улучшению его сигнатуры:

```rust,ignore
fn first_word(s: &String) -> &str {
```

Более опытные разработчики Rust написали бы сигнатуру из листинга  4-9, потому что она позволяет использовать одну функцию для значений обоих типов `&String` и `&str`.

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-09/src/main.rs:here}}
```

<span class="caption">Листинг 4-9: Улучшение функции <code>first_word</code> используя тип строкового среза для параметра <code>s</code></span>

Если есть строковый срез, то можно его передавать напрямую. Если есть `String`, можно передавать срез полностью всей строки `String`. Определение функции принимающей строковый срез вместо ссылки на `String` делает API более общим и полезным без потери функциональности:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-09/src/main.rs:usage}}
```

### Другие срезы

Как вы могли бы представить, строковые срезы относятся к строкам. Но также есть более общий тип среза. Рассмотрим массив:

```rust
let a = [1, 2, 3, 4, 5];
```

Подобно тому как мы хотели бы ссылаться на часть строки, мы можем захотеть ссылаться на часть массива. Мы можем делать это вот так:

```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]);
```

Данный срез имеет тип `&[i32]`. Он работает таким же образом, как и строковый срез, сохраняя ссылку на первый элемент и длину. Вы будете использовать данную разновидность среза для всех видов коллекций. Мы обсудим коллекции детально, когда будем говорить про векторы в Главе 8.

## Итоги

Концепции владения, заимствования и срезов обеспечивают защиту использования памяти в Rust. Rust даёт вам возможность контролировать использование памяти тем же способом, как другие языки системного программирования, но дополнительно предоставляет возможность автоматической очистки данных, когда их владелец покидает область видимости функции. Это означает, что не нужно писать и отлаживать дополнительный код, чтобы добиться такого контроля.

Владение влияет на множество других частей и концепций языка Rust. Мы будем говорить об этих концепциях на протяжении оставшихся частей книги. Давайте перейдём к Главе 5 и рассмотрим группировку частей данных в структуры `struct`.


["Сохранение текста с кодировкой UTF-8 в строках"]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
