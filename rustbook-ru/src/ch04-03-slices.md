## Тип срез

Другим типом данных, который не забирает во владение является *срез(slice)*. Срез позволяет ссылаться на смежную последовательность элементов из коллекции, вместо полной коллекции.

Рассмотрим небольшую программную проблему: необходимо написать функцию, входным параметром которой является строка. Выходным значением функции является первое слово, которое будет найдено в этой строке. Если функция не находит разделитель слов (пробела), она возвращает полную строку.

Давайте подумаем над сигнатурой этой функции:

```rust,ignore
fn first_word(s: &String) -> ?
```

Функция `first_word` имеет входной параметр типа `&String`. Нам не нужно владение переменной, так что это нормально. Но что мы должны вернуть? На самом деле у нас нет способа говорить о *части* строки. Тем не менее, для решения задачи мы можем найти индекс конца слова в строке. Попробуем сделать как на листинге 4-7:

<span class="filename">Файл: src/main.rs</span>

```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
```

<span class="caption">Листинг 4-7: Пример функции <code>first_word</code>, которая возвращает значение байтового индекса пробела внутри строкового параметра <code>String</code></span>

Для того, чтобы найти пробел в строке, мы превратим `String` в массив байт, используя метод `as_bytes` и пройдём по `String` элемент за элементом, проверяя является ли значение пробелом.

```rust,ignore
let bytes = s.as_bytes();
```

Далее, создаём итератор по массиву байт используя метод  `iter`:

```rust,ignore
for (i, &item) in bytes.iter().enumerate() {
```

Мы изучим итераторы более детально в главе 13. Сейчас, достаточно понять, что метод `iter` возвращает каждый элемент коллекции, а метод `enumerate` оборачивает результаты работы метода `iter` и возвращает каждый элемент как кортеж. Первый элемент этого кортежа возвращённый из  `enumerate` является индексом, а второй элемент - ссылкой на элемент. Такой способ перебора элементов массива является более удобным, чем считать индекс самостоятельно.

Так как метод `enumerate` возвращает кортеж, мы можем использовать шаблон деструктуризации кортежа, как и везде в Rust. Так в цикле `for`, мы указываем шаблон имеющий `i` для индекса в кортеже и `&item` для байта в кортеже. По причине получения ссылки на элемент из метода  `.iter().enumerate()`, используется `&` в шаблоне.

Внутри цикла `for`, ищем байт представляющий пробел используя синтаксис байт литерала. Если пробел найден, возвращается его позиция. Иначе, возвращается длина строки используя `s.len()`:

```rust,ignore
    if item == b' ' {
        return i;
    }
}

s.len()
```

Теперь у нас есть способ выяснить индекс первого слова в строке, но есть проблема. Мы возвращаем тип `usize` сам по себе, но он имеет значимое число только в контексте `&String`. Другими словами, так как оно является отдельным значением полученным из содержимого `String`, то нет гарантии, что оно будет действительным в будущем. Рассмотрим программу листинга 4-8, которая использует функцию `first_word` из листинга 4-7.

<span class="filename">Файл: src/main.rs</span>

```rust
# fn first_word(s: &String) -> usize {
#     let bytes = s.as_bytes();
#
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
#
#     s.len()
# }
#
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // 'word' получит значение 5

    s.clear(); // очистка String, что делает содержимое равное ""

    // 'word' все ещё содержит 5, но уже нет строки с которой мы
    // могли бы осмысленно использовать 5. значение word теперь полностью неверное!
}
```

<span class="caption">Listing 4-8: Сохранение результата вызова функции <code>first_word</code>, а затем изменение содержимого <code>String</code></span>

Данная программа компилируется без ошибок и возможно продолжит это делать, если мы воспользуемся `word` после вызова `s.clear()`. Так как значение `word` совсем не связано с состоянием переменной `s`, то `word` всё ещё имеет значение  `5`. Мы могли бы использовать `5` вместе с переменной `s` и попытаться извлечь первое слово, но это будет ошибкой, потому что содержимое `s` изменилось после того как мы сохранили `5` в переменной `word`.

Необходимость беспокоиться о том, что индекс в переменной `word` не синхронизируется с данными в переменной  `s` является утомительной и подверженной ошибкам! Управление этими индексами становится ещё более хрупким, если мы напишем функцию `second_word`. Её сигнатура могла бы выглядеть так:

```rust,ignore
fn second_word(s: &String) -> (usize, usize) {
```

Теперь мы отслеживаем начальный *и* конечный индексы, у нас ещё больше значений, которые рассчитаны на основе данных о содержимом в определённом состоянии, но которые также совсем не привязаны к данному состоянию. Теперь есть уже три не связанные переменные, которые необходимо синхронизировать.

К счастью в Rust есть решение данной проблемы: строковые срезы.

### Строковые срезы

Строковый срез - это ссылка на часть строки `String` и он выглядит следующим образом:

```rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```

Эта инициализация похожа на создание ссылки на переменную `String`, но с дополнительным условием - указанием отрезка `[0..5]`. Вместо ссылки на всю `String`, срез ссылается на её часть.

Мы можем создавать срезы, используя определение отрезка `[starting_index..ending_index]`, где `starting_index` означает первую позицию в срезе, а `ending_index` на единицу больше, чем последняя позиция. Во внутреннем представлении, структура данный срез хранит начальную позицию и длину среза, которая соответствует числу `ending_index` минус `starting_index`. Таким образом, в примере `let world = &s[6..11];`, переменная `world` будет срезом, которая содержит ссылку на 7-ой байт в `s` со значением длины равным 5.

Рисунок 4-12 отображает это на диаграмме.

<img alt="world containing a pointer to the 6th byte of String s and a length 5" src="../../rustbook-en/src/img/trpl04-06.svg" class="center" style="width: 50%;">

<span class="caption">Рисунок 4-12: Строковый срез ссылается на часть <code>String</code></span>

Если хочется начать с начального индекса (ноль), то с помощью Rust синтаксиса для диапазонов `..`, можно убрать число перед двоеточием. Другими словами, это эквивалентно:

```rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
```

Таким же образом, если срез включает последний байт строки `String`, можно убрать завершающее число. Это эквивалентно:

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
```

Также можно не указывать оба значения, чтобы получить срез всей строки Это эквивалентно:

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
```

> Внимание: Индексы среза строк должны соответствовать границам UTF-8 символов. Если вы попытаетесь получить срез нарушая границы символа в котором больше одного байта, то вы получите ошибку времени исполнения. В рамках этой главы мы будем предполагать только ASCII кодировку. Более детальное обсуждение UTF-8 находится в секции  [“Сохранение текста с кодировкой UTF-8 в строках”](ch08-02-strings.html#storing-utf-8-encoded-text-with-strings)<comment> главы 8.</comment>

Имея всю данную информацию, давайте перепишем метод `first_word` для возврата среза. Для обозначения типа "срез строки" существует запись `&str`:

<span class="filename">Файл: src/main.rs</span>

```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

Мы получаем индекс конца слова способом аналогичным тому, как мы это делали в листинге 4-7, поиском первого вхождения пробела. Когда пробел найден, возвращается строковый срез, используя начало строки и индекс пробела в качестве начального и конечного индексов.

Теперь, вызвав метод `first_word`, мы получим одно единственное значение, которое привязано к нижележащим данным. Значение, которое составлено из ссылки на начальную точку среза и количества элементов в срезе.

Аналогичным образом можно переписать и второй метод `second_word`:

```rust,ignore
fn second_word(s: &String) -> &str {
```

Теперь есть простое API, которое гораздо сложнее перепутать, потому что компилятор обеспечит то, что ссылки на `String` останутся действительными. Помните ошибку в программе листинга 4-8, когда мы получили индекс конца первого слова, но затем очистили строку, так что она стала не действительной? Тот код был логически не корректным, хотя не показывал никаких ошибок. Проблемы возникли бы позже, если бы мы попытались использовать индекс первого слова для пустой строки. Срезы делают не возможной данную ошибку и позволяют понять о наличии проблемы гораздо раньше. Использование версии метода со срезом `first_word` вернёт ошибку компиляции:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // error!

    println!("the first word is: {}", word);
}
```

Ошибка компиляции:

```text
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --> src/main.rs:18:5
   |
16 |     let word = first_word(&s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {}", word);
   |                                       ---- immutable borrow later used here
```

Напомним из правил заимствования, что если у нас есть неизменяемая ссылка на что-либо, то нельзя взять ещё изменяемую ссылку. Так как методу `clear` требуется обрезать `String`, ему нужно получить изменяемую ссылку. Rust не позволяет это сделать и компиляции не проходит. Rust не только упростил использование нашего API, но и исключил целый класс ошибок во время компиляции!

#### Строковые литералы это срезы

Напомним, что мы говорили о строковых литералах, хранящихся внутри двоичного файла. Теперь, когда мы знаем чем являются срезы, мы правильно понимаем что такое строковые литералы:

```rust
let s = "Hello, world!";
```

Тип `s` здесь является `&str` срезом, указывающим на конкретное место в коде программы. Это также объясняет, почему строковый литерал является неизменяемым, потому что тип `&str` это неизменяемая ссылка.

#### Строковые срезы как параметры

Знание о том, что можно брать срезы строковых литералов и значения `String` приводит к ещё одному улучшению `first_word` и вот его сигнатура:

```rust,ignore
fn first_word(s: &String) -> &str {
```

Более опытные разработчики Rust написали бы сигнатуру из листинга  4-9, потому что она позволяет использовать одну функцию для значений обоих типов `&String` и `&str`.

```rust,ignore
fn first_word(s: &str) -> &str {
```

<span class="caption">Пример 4-9: Улучшение функции <code>first_word</code> используя тип строкового среза для параметра <code>s</code></span>

Если есть строковый срез, то можно его передавать напрямую. Если есть `String`, можно передавать срез всей строки `String`. Определение функции принимающей строковый срез вместо ссылки на `String` делает API более общим и полезным без потери функциональности:

<span class="filename">Файл: src/main.rs</span>

```rust
# fn first_word(s: &str) -> &str {
#     let bytes = s.as_bytes();
#
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &s[0..i];
#         }
#     }
#
#     &s[..]
# }
fn main() {
    let my_string = String::from("hello world");

    // first_word работает со срезом `String`s
    let word = first_word(&my_string[..]);

    let my_string_literal = "hello world";

    // first_word работает со срезом строкового литерала
    let word = first_word(&my_string_literal[..]);

    // Т.к. строковые литералы уже является строковыми срезами,
    // данный код тоже работает, даже без синтаксиса среза!
    let word = first_word(my_string_literal);
}
```

### Другие срезы

Как вы могли бы представить, строковые срезы относятся к строкам. Но также есть более общий тип среза. Рассмотрим массив:

```rust
let a = [1, 2, 3, 4, 5];
```

Подобно тому как мы хотели бы ссылаться на часть строки, мы можем захотеть ссылаться на часть массива. Мы можем делать это вот так:

```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];
```

Данный срез имеет тип `&[i32]`. Он работает тем же способом, как и строковый срез, сохраняя ссылку на первый элемент и длину. Вы будете использовать данную разновидность среза для всех видов коллекций. Мы обсудим эти коллекции детально, когда будем говорить про векторы в главе 8.

## Итоги

Концепции владения, заимствования и срезов обеспечивают защиту использования памяти в Rust. Rust даёт вам возможность контролировать использование памяти тем же способом, как другие языки системного программирования, но даёт возможность автоматической очистки этих данных, когда их владелец покидает область видимости. Это означает, что не нужно писать и отлаживать дополнительный код, чтобы получить этот контроль.

Владение влияет на множество других частей и концепций языка Rust. Мы будем говорить об этих концепциях на протяжении оставшихся частей книги. Давайте перейдём к главе 5 и рассмотрим группировку частей данных в структуры `struct`.
