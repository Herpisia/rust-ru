## Типажи: определение общего поведения

*Типаж* сообщает компилятору Rust о функциональности, которой обладает определённый тип и которой он может поделиться с другими типами. Можно использовать типажи, чтобы определять общее поведение абстрактным способом. Можно использовать ограничения типажей для указания, что обобщение может быть любого типа с определённым поведением.

> Примечание: Типажи похожи на функциональность часто называемую *интерфейсами* в других языках, хотя и с некоторыми отличиями.

### Определение типажа

Поведение типа определяется теми методами, которые мы можем вызвать у данного типа. Различные типы разделяют одинаковое поведение, если мы можем вызвать одни и те же методы у всех типов. Определение типажей - это способ совместной группировки сигнатур методов для того, чтобы иметь множественное поведение, необходимое для достижения каких-либо целей.

Например, скажем есть несколько структур, которые имеют различный тип и различное количество текста: структура `NewsArticle` содержит новости, которые печатаются в различных местах в мире. Структура `Tweet` имеет 280 символов с мета-данными, обозначающими является ли он новым твитом, ответом на другой твит.

Мы хотим создать библиотеку медиа-агрегатора, которая может отображать сводку данных сохранённых в экземплярах структур `NewsArticle` или `Tweet`. Чтобы этого достичь, необходимо каждой структуре иметь возможность делать короткую сводку на основе имеющихся данных. Это должно происходить при вызове метода `summarizable` у экземпляра объекта. Пример (10-12) иллюстрирует определение типажа `Summary`, который выражает данное поведение:

<span class="filename">Файл: lib.rs</span>

```rust
pub trait Summary {
    fn summarize(&self) -> String;
}
```

<span class="caption">Код 10-12: Определение типажа <code>Summary</code>, который содержит поведение предоставленное методом <code>summarize</code></span>

Здесь мы объявляем типаж с использованием ключевого слова `trait`, а затем его название, которым является `Summary` в данном случае. Внутри фигурных скобок объявляются сигнатуры методов, которые описывают поведения типов, реализующих данных типаж, что в данном случае является `fn summarize(&self) -> String`.

После сигнатуры метода, вместо предоставления реализации в фигурных скобках, мы используем точку с запятой. Каждый тип, реализующий данный типаж, должен предоставить своё собственное поведение в теле метода. Компилятор обеспечит, что любой тип содержащий типаж `Summary`, будет также иметь и метод `summarize` объявленный с точно такой же сигнатурой.

Типаж может иметь несколько методов в описании его тела: сигнатуры методов перечислены на каждой строке и должны закачиваться символом ";".

### Реализация типажа у типа

Теперь, после определения желаемого поведение используя типаж `Summary` , можно реализовать его у типов в нашем медиа-агрегаторе. Листинг 10-13 показывает реализацию типажа `Summary` у структуры `NewsArticle`, которая использует заголовок, автора и место для создания возвращаемого значения метода `summarize` . Для структуры `Tweet` мы определяем реализацию `summarize` как имя пользователя сопровождаемое полным текстом твита, полагая содержание твита уже ограниченным 280 символами.

<span class="filename">Файл: lib.rs</span>

```rust
# pub trait Summary {
#     fn summarize(&self) -> String;
# }
#
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
```

<span class="caption">Код программы 10-13: Реализация типажа <code>Summarizable</code> для структур <code>NewsArticle</code> и <code>Tweet</code></span>

Реализация типажа у типа аналогична реализации обычных методов. Разница в том, что после `impl` мы ставим имя типажа, который мы хотим реализовать, затем используем ключевое слово `for`, а затем указываем имя типа, для которого мы хотим сделать реализацию типажа. Внутри блока `impl` мы помещаем сигнатуру метода объявленную в типаже. Вместо добавления точки с запятой в конце, после каждой сигнатуры используются фигурные скобки и тело метода заполняется конкретным поведением,  которое мы хотим получить у методов типажа для конкретного типа.

После того, как мы реализовали типаж, можно вызвать его методы у экземпляров `NewsArticle` и `Tweet` тем же способом, что и вызов обычных методов, например так:

```rust,ignore
let tweet = Tweet {
    username: String::from("horse_ebooks"),
    content: String::from("of course, as you probably already know, people"),
    reply: false,
    retweet: false,
};

println!("1 new tweet: {}", tweet.summarize());
```

Данный код напечатает: `1 new tweet: horse_ebooks: of course, as you probably already know, people`.

Обратите внимание, что, поскольку мы определили типаж `Summary` и `NewsArticle` и `Tweet` типы находятся в том же файле *lib.rs* примера 10-13, они все находятся в одной области видимости. Допустим, этот *lib.rs* предназначен для крейта, который мы назвали `aggregator` и кто-то ещё хочет использовать функциональность нашего крейта для реализации типажа `Summary` у структуры, определённой в области видимости внутри их библиотеки. Им нужно будет сначала подключить типаж в их область видимости. Они сделали бы это, указав `use aggregator::Summary;`, что позволит реализовать `Summary` для их типа. Типажу `Summary` также необходимо быть публичным для реализации в других крейтах, потому мы поставили ключевое слово `pub` перед `trait` в листинге 10-12.

Одно ограничение, на которое следует обратить внимание при реализации типажей это то, что мы можем реализовать типаж для типа, только если либо типаж, либо тип являются локальным для нашего крейта. Например, можно реализовать типажи из стандартной библиотеки, такие как `Display` для пользовательского типа `Tweet` являющимся частью функциональности крейта `aggregator`, потому что тип `Tweet` является локальным в крейте `aggregator`. Мы также можем реализовать типаж `Summary` для `Vec<T>` в нашем крейте `aggregator`, потому что типаж `Summary`  является локальным для крейта `aggregator`.

Но мы не можем реализовать внешние типажи для внешних типов. Например, мы не можем реализовать функцию `Display` для `Vec<T>` в нашем крейте `aggregator`, потому что и типаж `Display` и тип `Vec<T>` определены в стандартной библиотеке, а не локальные в нашем крейте `aggregator`. Это ограничение является частью свойства программы называемое *согласованность*, а точнее *сиротское правило* (orphan rule), называемое так, потому что родительский тип не представлен. Это правило гарантирует, что код других людей не может сломать ваш код и наоборот. Без этого правила два крейта могли бы реализовать один типаж для одинакового типа и Rust не будет знать, какой реализацией пользоваться.

### Реализации по умолчанию

Иногда полезно иметь поведение по умолчанию для некоторых или всех методов в типаже вместо того, чтобы требовать реализации всех методов в каждом типе, реализующим данный типаж. Затем, когда мы реализуем типаж для определённого типа, можно сохранить или переопределить поведение каждого метода по умолчанию уже внутри типов.

В примере 10-14 показано, как указать строку по умолчанию для метода `summarize` из типажа `Summary` вместо определения только сигнатуры метода, как мы сделали в примере 10-12.

<span class="filename">Файл: src/lib.rs</span>

```rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
```

<span class="caption">Листинг 10-14. Определение типажа <code>Summary</code> с реализацией метода <code>summarize</code> по умолчанию</span>

Для использования реализации по умолчанию при создании сводки у экземпляров `NewsArticle` вместо определения пользовательской реализации, мы указываем пустой блок `impl` с `impl Summary for NewsArticle {}`.

Хотя мы больше не определяем метод `summarize` непосредственно в `NewsArticle`, мы предоставили реализацию по умолчанию и указали, что `NewsArticle` реализует типаж `Summary`. В результате мы всё ещё можем вызвать метод `summarize` у экземпляра `NewsArticle`, например так:

```rust,ignore
let article = NewsArticle {
    headline: String::from("Penguins win the Stanley Cup Championship!"),
    location: String::from("Pittsburgh, PA, USA"),
    author: String::from("Iceburgh"),
    content: String::from("The Pittsburgh Penguins once again are the best
    hockey team in the NHL."),
};

println!("New article available! {}", article.summarize());
```

Этот код печатает `New article available! (Read more...)` .

Создание реализации по умолчанию для метода `summarize` не требует от нас изменений чего-либо в реализации `Summary` для типа `Tweet` в листинге 10-13. Причина заключается в том, что синтаксис для переопределения реализации по умолчанию является таким же, как синтаксис для реализации метода типажа, который не имеет реализации по умолчанию.

Реализации по умолчанию могут вызывать другие методы с том же типаже, даже если эти другие методы не имеют реализации по умолчанию. Таким образом, типаж может предоставить много полезной функциональности и только требует от разработчиков  указывать небольшую его часть. Например, мы могли бы определить типаж `Summary` имеющий метод `summarize_author`, реализация которого требуется, а затем определить метод `summarize` который имеет реализацию по умолчанию, которая внутри вызывает метод `summarize_author` :

```rust
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
```

Чтобы использовать такую версию типажа `Summary`, нужно только определить метод `summarize_author`, при реализации типажа для типа:

```rust,ignore
impl Summary for Tweet {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
```

После того, как мы определим `summarize_author`, можно вызвать `summarize` для экземпляров структуры `Tweet` и реализация по умолчанию метода `summarize` будет вызывать определение `summarize_author` которое мы уже предоставили. Так как мы реализовали метод `summarize_author` типажа `Summary`, то типаж даёт нам поведение метода `summarize` без необходимости писать код.

```rust,ignore
let tweet = Tweet {
    username: String::from("horse_ebooks"),
    content: String::from("of course, as you probably already know, people"),
    reply: false,
    retweet: false,
};

println!("1 new tweet: {}", tweet.summarize());
```

Этот код печатает `1 new tweet: (Read more from @horse_ebooks...)` .

Обратите внимание, что невозможно вызвать реализацию по умолчанию из переопределённой реализации того же метода.

### Типажи как параметры

Теперь, когда вы знаете, как определять и реализовывать типажи, можно изучить, как использовать типажи, чтобы определить функции, которые принимают много различных типов.

Например, в листинге 10-13 мы реализовали типаж `Summary` для типов структур `NewsArticle` и `Tweet` . Можно определить функцию `notify` которая вызывает метод `summarize` с параметром `item`, который имеет тип реализующий типаж `Summary` . Для этого можно использовать синтаксис `impl Trait`, например так:

```rust,ignore
pub fn notify(item: impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```

Вместо конкретного типа у параметра `item` указывается ключевое слово `impl`  и имя типажа. Этот параметр принимает любой тип, который реализует указанный типаж. В теле `notify` мы можем вызывать любые методы у экземпляра `item`, которые приходят из типажа `Summary`, такие как `summarize` . Мы можем вызвать `notify` и передать в него любой экземпляр `NewsArticle` или `Tweet` . Код, который вызывает данную функцию с любым другим типом, таким как `String` или `i32`, не будет компилироваться, потому что эти типы не реализуют типаж `Summary`.

#### Синтаксис ограничения типажа

Синтаксис `impl Trait` работает для простых случаев, но на самом деле является синтаксическим сахаром для более длинной формы, которая называется *ограничением типажа*; это выглядит так:

```rust,ignore
pub fn notify<T: Summary>(item: T) {
    println!("Breaking news! {}", item.summarize());
}
```

Эта более длинная форма эквивалентна примеру в предыдущем разделе, но он более многословный. Мы помещаем границы типажа с объявлением параметра обобщённого типа после двоеточия и внутри угловых скобок.

Синтаксис `impl Trait` удобен и делает более выразительным код в простых случаях. Синтаксис ограничений типажа может выразить большую сложность в других случаях. Например, у нас может быть два параметра, которые реализуют типаж `Summary`. Использование синтаксиса `impl Trait` выглядит следующим образом:

```rust,ignore
pub fn notify(item1: impl Summary, item2: impl Summary) {
```

Если бы мы хотели, чтобы эта функция позволяла иметь `item1` и `item2` разных типов, то использование `impl Trait` было бы уместно (до тех пор, пока оба типа реализуют `Summary` ). Если мы хотим форсировать, чтобы оба параметра имели одинаковый тип, то это можно выразить только с использованием ограничения типажа, например так:

```rust,ignore
pub fn notify<T: Summary>(item1: T, item2: T) {
```

Обобщённый тип `T` указан для типов параметров `item1` и `item2` и ограничивает функцию так, что конкретные значения типов переданные аргументами в  `item1` и `item2` должны быть одинаковыми.

#### Задание нескольких границ типажей с помощью синтаксиса `+`

Также можно указать более одного ограничения типажа. Скажем, мы хотели бы использовать в методе `notify` для параметра `item` с форматированием отображения, также как метод `summarize`: для этого мы указываем в определении `notify`, что `item` должен реализовывать как типаж `Display` так и `Summary`. Мы можем сделать это используя синтаксис `+` :

```rust,ignore
pub fn notify(item: impl Summary + Display) {
```

Синтаксис `+` также допустим с ограничениями типажа для обобщённых типов:

```rust,ignore
pub fn notify<T: Summary + Display>(item: T) {
```

При наличии двух ограничений типажа, тело метода `notify` может вызывать `summarize` и использовать `{}` для форматирования `item` .

#### Более ясные границы типажа с помощью `where`

Использование слишком большого количества ограничений типажа имеет свои недостатки. Каждый обобщённый тип имеет свои границы типажа, поэтому функции с несколькими параметрами обобщённого типа могут содержать много информации об ограничениях между названием функции и списком её параметров затрудняющих чтение сигнатуры. По этой причине в Rust есть альтернативный синтаксис для определения ограничений типажа внутри предложения `where` после сигнатуры функции. Поэтому вместо того, чтобы писать так:

```rust,ignore
fn some_function<T: Display + Clone, U: Clone + Debug>(t: T, u: U) -> i32 {
```

можно использовать предложение `where` , например так:

```rust,ignore
fn some_function<T, U>(t: T, u: U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{
```

Сигнатура этой функции менее загромождена: название функции, список параметров, и возвращаемый тип близки друг к другу, похожи на функцию без множества ограничений типажа.

### Возвращая типы реализующие типажи

Также можно использовать синтаксис `impl Trait` в возвращаемой позиции, чтобы вернуть значение некоторого типа реализующего типаж, как показано здесь:

```rust,ignore
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from("of course, as you probably already know, people"),
        reply: false,
        retweet: false,
    }
}
```

Используя `impl Summary` для возвращаемого типа, мы указываем, что функция `returns_summarizable` возвращает некоторый тип, который реализует типаж `Summary` без обозначения конкретного типа. В этом случае `returns_summarizable` возвращает `Tweet`, но код, вызывающий эту функцию, этого не знает.

Возможность возвращать тип, который указан только как реализующий типаж, является особенно полезной в контексте замыканий и итераторов, которые мы рассмотрим в главе 13. Замыкания и итераторы создают типы, которые знает только компилятор или типы, которые очень долго указывать. Синтаксис `impl Trait` позволяет кратко указать, что функция возвращает некоторый тип, который реализует типаж `Iterator` без необходимости писать очень длинный тип.

Однако можно использовать только `impl Trait`, если возвращаете только один тип. Например, данный код, который возвращает или `NewsArticle` или `Tweet`, а в качестве возвращаемого типа объявляет `impl Summary`, не будет работать:

```rust,ignore,does_not_compile
fn returns_summarizable(switch: bool) -> impl Summary {
    if switch {
        NewsArticle {
            headline: String::from("Penguins win the Stanley Cup Championship!"),
            location: String::from("Pittsburgh, PA, USA"),
            author: String::from("Iceburgh"),
            content: String::from("The Pittsburgh Penguins once again are the best
            hockey team in the NHL."),
        }
    } else {
        Tweet {
            username: String::from("horse_ebooks"),
            content: String::from("of course, as you probably already know, people"),
            reply: false,
            retweet: false,
        }
    }
}
```

Возврат `NewsArticle` или `Tweet` не допускается из-за ограничений того, как реализован синтаксис `impl Trait` в компиляторе. Мы рассмотрим, как написать функцию с таким поведением в разделе [«Использование объектов типажей, которые разрешены для значений или разных типов».](ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types)<comment> главы 17.</comment>

### Исправление кода функции `largest` с помощью ограничений типажа

Теперь, когда вы знаете, как указать поведение, которое вы хотите использовать с помощью параметра обобщённого типа с ограничениями, давайте вернёмся к листингу 10-5, чтобы исправить определение функции `largest`, которая использует параметр общего типа! В прошлый раз мы пытались запустить этот код, но получили ошибку:

```text
error[E0369]: binary operation `>` cannot be applied to type `T`
 --> src/main.rs:5:12
  |
5 |         if item > largest {
  |            ^^^^^^^^^^^^^^
  |
  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
```

В теле функции `largest` мы хотели сравнить два значения типа `T` используя оператор больше чем ( `>` ). Так как этот оператор определён у типажа `std::cmp::PartialOrd` из стандартной библиотеки как метод по умолчанию, то нам нужно указать `PartialOrd` в качестве ограничения для типа `T`, так что функция `largest` сможет работать со срезами любого типа, которые мы можем сравнить. Нам не нужно подключать `PartialOrd` в область видимости, потому что он есть в авто-импорте. Изменим сигнатуру `largest`, чтобы она выглядела так:

```rust,ignore
fn largest<T: PartialOrd>(list: &[T]) -> T {
```

На этот раз при компиляции кода мы получаем другой набор ошибок:

```text
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --> src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       help: consider using a reference instead: `&list[0]`

error[E0507]: cannot move out of borrowed content
 --> src/main.rs:4:9
  |
4 |     for &item in list.iter() {
  |         ^----
  |         ||
  |         |hint: to prevent move, use `ref item` or `ref mut item`
  |         cannot move out of borrowed content
```

Ключевая строка в этой ошибке `cannot move out of type [T], a non-copy slice`. С нашими не обобщёнными версиями функции `largest` мы пытались найти самый большой элемент только для типа `i32` или `char`. Как обсуждалось в разделе [«Данные только для стека: Копирование»](ch04-01-what-is-ownership.html#stack-only-data-copy) главы 4, типы подобные `i32` и `char`, имеющие известный размер, могут храниться в стеке, поэтому они реализуют типаж `Copy`. Но когда мы сделали функцию `largest` обобщённой, для параметра `list` стало возможным иметь типы, которые не реализуют типаж `Copy`. Следовательно, мы не сможем переместить значение из переменной `list[0] ` в переменную `largest`, в результате чего появляется это ошибка.

Чтобы вызывать этот код только с теми типами, которые реализуют типаж `Copy`, можно добавить типаж `Copy` в список ограничений типа `T`! Листинг 10-15 показывает полный код обобщённой функции `largest`, которая будет компилироваться, пока типы значений среза передаваемых в функцию, реализуют типажи `PartialOrd` *и* `Copy`, как это делают `i32` и `char`.

<span class="filename">Файл: src/main.rs</span>

```rust
fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
```

<span class="caption">Листинг 10-16: Объявление функции <code>largest</code> работающей с любыми обобщёнными типами, которые реализуют типажи <code>PartialOrd</code> и <code>Copy</code></span>

Если мы не хотим ограничить функцию `largest` типами, которые реализуют типаж `Copy`, мы могли бы указать, что `T` имеет ограничение типажа `Clone` вместо `Copy` . Затем можно клонировать каждое значение в срезе, если хотим чтобы функция `largest` забирала владение. Использование функции `clone` означает, что потенциально делается больше выделений кучи для типов, которые владеют данными в куче, такие как `String` и выделение памяти в кучи могут быть медленными, если мы работаем с большими объёмами данных.

Ещё один способ мы могли бы реализовать в `largest` - это функция возвращающая ссылку на значение `T` из  среза. Если мы изменим возвращаемый тип на `&T` вместо `T`, то тем самым изменяем тело функции, чтобы она возвращала ссылку, тогда не нужны ограничения типажа `Clone` или `Copy` и мы могли бы избежать выделения кучи. Попробуйте реализовать эти альтернативные решения самостоятельно!

### Использование ограничений типажа для условной реализации методов

Используя ограничение типажа с блоком `impl`, который использует параметры обобщённого типа, можно реализовать методы условно, для тех типов, которые реализуют указанный типаж. Например, тип `Pair<T>` в листинге 10-16 всегда реализует функцию `new`. Но `Pair<T>` реализует только метод `cmp_display`, если его внутренний тип `T` реализует типаж `PartialOrd` позволяющий сравнивать в том числе *и* типаж `Display` позволяющий печать.

```rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self {
            x,
            y,
        }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```

<span class="caption">Листинг 10-17: Условная реализация методов у обобщённых типов в зависимости от ограничений типажа</span>

Мы также можем условно реализовать типаж для любого типа, который реализует другой типаж. Реализации типажа для любого типа, который удовлетворяет ограничениям типажа называются *общими реализациями* и широко используются в стандартной библиотеке Rust. Например, стандартная библиотека реализует типаж `ToString` для любого типа, который реализует типаж `Display`. Блок `impl` в стандартной библиотеке выглядит примерно так:

```rust,ignore
impl<T: Display> ToString for T {
    // --snip--
}
```

Поскольку стандартная библиотека имеет эту общую реализацию, то можно вызвать метод `to_string` определённый типажом `ToString` для любого типа, который реализует типаж `Display`. Например, мы можем превратить целые числа в их соответствующие `String` значения как ниже, потому что целые числа реализуют типаж `Display`:

```rust
let s = 3.to_string();
```

Общие реализации приведены в документации к типажу в разделе «Implementors».

Типажи и ограничения типажей позволяют писать код, который использует параметры обобщённого типа для уменьшения дублирование, а также указывая компилятору, что мы хотим обобщённый тип, чтобы иметь определённое поведение. Затем компилятор может использовать информацию про ограничения типажа, чтобы проверить, что все конкретные типы, используемые с нашим кодом, обеспечивают правильное поведение. В динамически типизированных языках мы получили бы ошибку в время выполнения, если бы вызвали метод для типа, который не реализует тип определяемый методом. Но Rust перемещает эти ошибки на время компиляции, поэтому мы вынуждены исправить проблемы, прежде чем наш код сможет работать. Кроме того, мы не должны писать код, который проверяет поведение во время выполнения, потому что это уже проверено во время компиляции. Это повышает производительность без необходимости отказываться от гибкости обобщённых типов.

Другой тип обобщения, который мы уже использовали, называется *временами жизни* (lifetimes). Вместо гарантирования того, что тип ведёт себя так, как нужно, время жизни гарантирует что ссылки действительны до тех пор, пока они нужны. Давайте посмотрим, как времена жизни это делают.
