## Обработка группы элементов с помощью итераторов

Шаблон итератора позволяет выполнять некоторые задачи над последовательностью элементов. Итератор отвечает за логику итерации по каждому элементу и определяет, когда последовательность завершилась. Когда вы используете итераторы, вам не нужно переопределять эту логику самостоятельно.

Итераторы В Rust *ленивы*, то есть они не делают ничего, пока вы не вызовете методы, которые потребляют итератор. Например, код в листинге 13-10 создаёт итератор по элементам вектора `v1`, вызывая метод `iter`, определённый для `Vec<T>`. Сам по себе этот код не делает ничего полезного.

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-10/src/main.rs:here}}
```

<span class="caption">Листинг 13-10: Создание итератора</span>

Создав итератор, можно использовать его различными способами. В листинге 3-5 главы 3 мы использовали итераторы с циклами `for`, чтобы выполнить некоторый код для каждого элемента, хотя только вкратце останавливались на том, что делал вызов `iter` до этих пор.

Пример в листинге 13-14 отделяет создание итератора от его использования в цикле `for`. Итератор хранится в переменной `v1_iter`, и в это время итерация не выполняется. Когда цикл `for` вызывается с использованием итератора `v1_iter`, каждый элемент итератора используется в одной итерации цикла, которая выводит значение этого элемента.

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-11/src/main.rs:here}}
```

<span class="caption">Листинг 13-11: Использование итератора в цикле <code>for</code></span>

В языках, которые не имеют итераторов в стандартной библиотеке, вы, вероятно, написали бы эту же функцию следующим образом: взять переменную со значением 0, использовать её для индексации вектора, чтобы получить значение, и увеличивать её значение в цикле, пока не будет достигнуто общее количество элементов в векторе.

Итераторы делают все эти шаги за вас, сокращая повторяющийся код, который вы потенциально могли бы испортить. Итераторы дают вам больше гибкости для использования одной и той же логики с различными типами последовательностей, а не только со структурами данных, которые можно индексировать, типа векторов. Давайте посмотрим как итераторы это делают.

### Типаж `Iterator` и метод `next`

Все итераторы реализуют типаж `Iterator`, который определён в стандартной библиотеке. Его определение выглядит так:

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // methods with default implementations elided
}
```

Обратите внимание данное объявление использует новый синтаксис: `type Item` и `Self::Item`, которые определяют *ассоциированный тип* (associated type) с этим типажом. Мы подробнее поговорим о ассоциированных типах в главе 19. Сейчас вам нужно знать, что этот код требует от реализаций типажа `Iterator` определить требуемый им тип `Item` и данный тип `Item` используется в методе `next`. Другими словами, тип `Item` будет являться типом элемента, который возвращает итератор.

Типаж `Iterator` требует, чтобы разработчики определяли только один метод: метод `next`, который возвращает один элемент итератора за раз обёрнутый в вариант `Some` и когда итерация завершена, возвращает `None`.

Мы можем вызвать у итераторов метод `next` напрямую; В листинге 13-15 показано, какие значения возвращаются в результате повторных вызовов `next` на итераторе, созданном из вектора.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-12/src/lib.rs:here}}
```

<span class="caption">Листинг 13-12: Вызов метода <code>next</code> на итераторе</span>

Обратите внимание, что нам нужно сделать переменную `v1_iter` изменяемой: вызов метода `next` итератора изменяет внутреннее состояние итератора, которое итератор использует для отслеживания того, где он находится в последовательности. Другими словами, этот код *потребляет* (consumes) или использует итератор. Каждый вызов `next` потребляет элемент из итератора. Нам не нужно было делать изменяемой `v1_iter` при использовании цикла `for`, потому что цикл забрал во владение `v1_iter` и сделал её изменяемой неявно для нас.

Заметьте также, что значения, которые мы получаем при вызовах `next` являются неизменяемыми ссылками на значения в векторе. Метод `iter` создаёт итератор по неизменяемым ссылкам. Если мы хотим создать итератор, который становится владельцем `v1` и возвращает принадлежащие ему значения, мы можем вызвать `into_iter` вместо `iter`. Точно так же, если мы хотим перебирать изменяемые ссылки, мы можем вызвать `iter_mut` вместо `iter`.

### Методы, которые потребляют итератор

У типажа `Iterator` есть несколько методов, реализация которых по умолчанию предоставляется стандартной библиотекой; вы можете узнать об этих методах, просмотрев документацию API стандартной библиотеки для `Iterator`. Некоторые из этих методов вызывают `next` в своём определении, поэтому вам необходимо реализовать метод `next` при реализации типажа `Iterator`.

Методы, вызывающие `next`, называются потребляющими адаптерами (*consuming adaptors*), поскольку их вызов использует итератор. Примером потребляющего адаптера является метод `sum`. Он становится владельцем итератора и перемещается по элементам, многократно вызывая `next`, тем самым потребляя итератор. Он выполняет итерацию для каждого элемента и добавляет его к промежуточной сумме, возвращая итоговую сумму после завершения итерации. В листинге 13-13 есть тест, иллюстрирующий использование `sum`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-13/src/lib.rs:here}}
```

<span class="caption">Листинг 13-13: Вызов метода <code>sum</code> для получения суммы всех элементов итератора</span>

Мы не можем использовать `v1_iter` после вызова метода `sum`, потому что `sum` забирает по владение итератор у которого вызван метод.

### Методы, которые создают другие итераторы

Другие методы, определённые в `Iterator`, известные как *адаптеры итераторов (iterator adaptors)*, позволяют преобразовывать в разные виды итераторов. Вы можете связать в последовательность несколько вызовов адаптеров итераторов для выполнения сложных действий в удобном виде. Но поскольку все итераторы ленивы, вы должны вызвать один из потребляющих методов, чтобы получить результат работы цепочки адаптеров.

В листинге 13-14 показан пример использования адаптера `map`, который требует замыкание, чтобы применить его к каждому элементу и создать новый итератор. Замыкание здесь создаёт новый итератор, в котором каждый элемент вектора был увеличен на 1. Однако этот код выдаёт предупреждение:

<span class="filename">Файл: src/main.rs</span>

```rust,not_desired_behavior
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-14/src/main.rs:here}}
```

<span class="caption">Листинг 13-14. Использование адаптера <code>map</code>  для создания нового итератора</span>

Мы получаем следующее предупреждение:

```console
{{#include ../listings/ch13-functional-features/listing-13-14/output.txt}}
```

Код в листинге 13-17 ничего не делает; замыкание никогда не вызывается. Предупреждение напоминает нам, почему это так: адаптеры итераторов ленивы и мы должны поглотить итератор чтобы увидеть результат.

Чтобы исправить это и поглотить итератор, мы воспользуемся методом `collect`, который мы уже использовали в главе 12 с `env::args` в листинге 12-1. Этот метод использует итератор и собирает полученные значения в коллекцию указанного типа.

В листинге 13-15 мы собираем результаты итерации по итератору, который возвращается из вызова `map` в вектор. Этот вектор будет содержать каждый элемент из исходного вектора, увеличенный на 1.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-15/src/main.rs:here}}
```

<span class="caption">Листинг 13-15: Вызов метода <code>map</code> для создания нового итератора и затем вызов метода <code>collect</code> для создания и использования нового итератора, чтобы создать новый вектор с данными</span>

Поскольку `map` принимает замыкание, мы можем указать любую операцию, которую хотим выполнить с каждым элементом. Это отличный пример того, как замыкания позволяют настраивать какое-то поведение при повторном использовании итерационного поведения, предоставляемого типажом `Iterator` .

### Использование замыканий, которые захватывают переменные окружения

Теперь, когда мы представили итераторы, мы можем продемонстрировать общее использование замыканий, которые захватывают их окружение используя адаптер итератора `filter`. Метод `filter` в итераторе принимает замыкание, которое берет каждый элемент из итератора и возвращает логическое значение. Если замыкание возвращает `true`, значение будет включено в итератор, созданный методом `filter`. Если замыкание возвращает `false`, значение не будет включено в итоговый итератор.

В листинге 13-16 мы используем метод `filter` с замыканием, которое захватывает переменную `shoe_size` из своего окружения, чтобы выполнить итерацию по коллекции экземпляров структуры `Shoe`. Он вернёт только ту обувь, которая имеет указанный размер.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-16/src/lib.rs}}
```

<span class="caption">Листинг 13-16: Использование метода <code>filter</code> вместе с замыканием, которое захватывает параметр <code>shoe_size</code></span>

Функция `shoes_in_size` принимает в качестве параметров вектор с экземплярами обуви и размер обуви, а возвращает вектор, содержащий только обувь указанного размера.

В теле `shoes_in_my_size` мы вызываем `into_iter` чтобы создать итератор, который становится владельцем вектора. Затем мы вызываем `filter`, чтобы превратить этот итератор в другой, который содержит только элементы, для которых замыкание возвращает `true`.

Замыкание захватывает параметр `shoe_size` из окружения и сравнивает его с размером каждой пары обуви, оставляя только обувь указанного размера. Наконец, вызов `collect` собирает значения, возвращаемые адаптированным итератором, в вектор, возвращаемый функцией.

Тест показывает, что когда мы вызываем `shoes_in_my_size`, мы возвращаем только туфли, размер которых совпадает с указанным нами значением.
