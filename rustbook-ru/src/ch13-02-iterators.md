## Обработка группы элементов с помощью итераторов

Шаблон итератора позволяет выполнять некоторые задачи над   последовательностью элементов. Итератор отвечает за логику итерации по каждому элементу и определяет, когда последовательность завершилась. Когда вы используете итераторы, вам не нужно переопределять эту логику самостоятельно.

В Rust итераторы являются *ленивыми*, что означает, что они не действуют, пока вы не вызовете методы, которые вызывают получение результата (consume) использования итератора. Например, код в листинге 13-13 создаёт итератор для элементов в векторе `v1`, вызывая метод `iter`, определённый в `Vec<T>`. Этот код сам по себе не делает ничего полезного.

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
```

<span class="caption">Листинг 13-13: Создание итератора</span>

Создав итератор, можно использовать его различными способами. В листинге 3-5 главы 3 мы использовали итераторы с циклами `for`, чтобы выполнить некоторый код для каждого элемента, хотя только вкратце останавливались на том, что делал вызов `iter` до этих пор.

Пример в листинге 13-14 отделяет создание итератора от использования итератора в цикле `for`. Итератор хранится в переменной `v1_iter` и в этот момент итерация ещё не выполняется. Когда цикл `for` вызывается с использованием итератора `v1_iter`, то каждый элемент в итераторе используется в одной итерации цикла, которая выводит каждое значение.

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!("Got: {}", val);
}
```

<span class="caption">Листинг 13-14: Использование итератора в цикле <code>for</code></span>

В языках, которые не имеют итераторов, предоставляемых стандартными библиотеками, вы, вероятно, напишите эту же функциональность, инициализируя переменную с начальным индексом 0, используя эту переменную для индексации в векторе, получая значение и увеличивая значение переменной в цикле, пока не достигнете общего количества элементов в векторе.

Итераторы обрабатывают всю эту логику для вас, сокращая повторяющийся код, в котором вы  можете потенциально напутать. Итераторы дают большую гибкость в использовании одной и той же логики со многими различными типами последовательностей, а не только с структурами данных, в которые вы можете индексировать элементы, например, с векторами. Давайте рассмотрим, как итераторы это делают.

### Типаж `Iterator` и метод `next`

Все итераторы реализуют типаж стандартной библиотеки `Iterator`. Так выглядит его объявление:

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // методы с реализацией по умолчанию опущены
}
```

Обратите внимание данное объявление использует новый синтаксис: `type Item` и `Self::Item`, которые определяют *ассоциированный тип* (associated type) с этим типажом. Мы подробнее поговорим о ассоциированных типах в главе 19. Сейчас вам нужно знать, что этот код требует от реализаций типажа `Iterator` определить требуемый им тип `Item` и данный тип `Item` используется в методе `next`. Другими словами, тип `Item` будет являться типом элемента, который возвращает итератор.

Типаж `Iterator` требует, чтобы разработчики определяли только один метод: метод `next`, который возвращает один элемент итератора за раз обёрнутый в вариант `Some` и когда итерация завершена, возвращает `None`.

Мы можем вызвать метод `next` напрямую у итераторов. В листинге 13-15 показано, какие значения возвращаются при повторных вызовах метода `next` у итератора созданного из вектора.

<span class="filename">Файл: src/lib.rs</span>

```rust
#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&1));
    assert_eq!(v1_iter.next(), Some(&2));
    assert_eq!(v1_iter.next(), Some(&3));
    assert_eq!(v1_iter.next(), None);
}
```

<span class="caption">Листинг 13-15: Вызов метода итератора <code>next</code></span>

Обратите внимание, что нам нужно сделать переменную `v1_iter` изменяемой: вызов метода `next` итератора изменяет внутреннее состояние итератора, которое итератор использует для отслеживания того, где он находится в последовательности. Другими словами, этот код *потребляет* (consumes) или использует итератор. Каждый вызов `next` съедает элемент из итератора. Нам не нужно было делать изменяемой `v1_iter` при использовании цикла `for`, потому что цикл забрал во владение `v1_iter` и сделал её изменяемой неявно для нас.

Также следует учесть, что значения, которые мы получаем вызывая `next`, являются неизменяемыми ссылками на значения в векторе. Метод `iter` создаёт итератор над неизменными ссылками. Если мы хотим создать итератор, который получает во владение `v1` и возвращает его значения как владелец, можно вызвать `into_iter` вместо `iter`. Точно так же, если мы хотим перебирать изменяемые ссылки, можно вызвать `iter_mut` вместо `iter`.

### Методы, которые потребляют итератор

Типаж `Iterator` имеет ряд различных методов с реализациями по умолчанию, предоставленных стандартной библиотекой. Вы можете узнать больше об этих методах, заглянув в документацию API стандартной библиотеки для типажа `Iterator`. Некоторые из этих методов вызывают внутри метод `next`, поэтому мы должны реализовывать метод `next` при реализации типажа `Iterator`.

Методы, вызывающие `next`, называются *потребляющими адаптерами* (consuming adaptors), поскольку их вызов использует итератор. Примером потребляющего адаптера является метод `sum`. Он становится владельцем итератора и перемещается по элементам, многократно вызывая `next`, тем самым потребляя итератор. Он выполняет итерацию для каждого элемента и добавляет его к промежуточной сумме, возвращая итоговую сумму после завершения итерации. В листинге 13-16 есть тест, иллюстрирующий использование `sum`:

<span class="filename">Файл: src/lib.rs</span>

```rust
#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
```

<span class="caption">Листинг 13-16: Вызов метода <code>sum</code> для получения суммы всех элементов итератора</span>

Переменную `v1_iter` после вызова метода `sum` уже использовать нельзя, потому что `sum` забирает по владение итератор на котором метод вызван.

### Методы, которые создают другие итераторы

Другие методы, определённые у типажа `Iterator`, известны как *адаптеры итераторов* (iterator adaptors) и позволяют изменять итераторы в итераторы разных видов. Вы можете объединить несколько обращений к адаптерам итераторов для выполнения сложных действий в удобной форме. Но поскольку все итераторы ленивы, вы должны вызвать один из методов адаптера потребителя (consuming adaptor), чтобы получить результаты из вызовов адаптеров итератора.

В листинге 13-17 показан пример вызова метода адаптера итератора `map`, который берет замыкание для вызова каждого элемента для создания нового итератора. Замыкание здесь создаёт новый итератор, в котором каждый элемент вектора был увеличен на 1. Однако этот код выдаёт предупреждение:

<span class="filename">Файл: src/main.rs</span>

```rust,not_desired_behavior
let v1: Vec<i32> = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
```

<span class="caption">Листинг 13-17: Вызов итератора-адаптера <code>map</code> для создания нового итератора</span>

Мы получаем следующее предупреждение:

```text
warning: unused `std::iter::Map` which must be used: iterator adaptors are lazy
and do nothing unless consumed
 --> src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(unused_must_use)] on by default
```

Код в листинге 13-17 ничего не делает; указанное нами замыкание никогда не вызывается. Предупреждение напоминает нам, почему это так: адаптеры итераторов ленивы и здесь нужно воспользоваться (consume) итератором.

Чтобы исправить это и использовать итератор, мы воспользуемся методом `collect`, который использовали в главе 12 вместе с `env::args` в листинге 12-1. Этот метод потребляет итератор и собирает полученные значения в тип данных коллекцию.

В листинге 13-18 мы собираем результаты итерации по итератору, который возвращается из вызова `map` в вектор. Этот вектор будет содержать каждый элемент из исходного вектора, увеличенный на 1.

<span class="filename">Файл: src/main.rs</span>

```rust
let v1: Vec<i32> = vec![1, 2, 3];

let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
```

<span class="caption">Листинг 13-18: Вызов метода <code>map</code> для создания нового итератора и затем вызов метода <code>collect</code> для создания и использования нового итератора, чтобы создать новый вектор с данными</span>

Так как `map` принимает замыкание, мы можем указать любую операцию, которую хотим применить над каждым элементом. Это прекрасный пример того, как замыкания позволяют настраивать некоторое поведение пере используя поведение итератора, которое обеспечивает типаж `Iterator`.

### Использование замыканий, которые захватывают переменные окружения

Теперь, когда мы представили итераторы, мы можем продемонстрировать общее использование замыканий, которые захватывают их окружение используя адаптер итератора `filter`. Метод `filter` в итераторе принимает замыкание, которое берет каждый элемент из итератора и возвращает логическое значение. Если замыкание возвращает `true`, значение будет включено в итератор, созданный методом `filter`. Если замыкание возвращает `false`, значение не будет включено в итоговый итератор.

В листинге 13-19 мы используем метод `filter` с замыканием, которое захватывает переменную `shoe_size` из своего окружения, чтобы выполнить итерацию по коллекции экземпляров структуры `Shoe`. Он вернёт только ту обувь, которая имеет указанный размер.

<span class="filename">Файл: src/lib.rs</span>

```rust
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter()
        .filter(|s| s.size == shoe_size)
        .collect()
}

#[test]
fn filters_by_size() {
    let shoes = vec![
        Shoe { size: 10, style: String::from("sneaker") },
        Shoe { size: 13, style: String::from("sandal") },
        Shoe { size: 10, style: String::from("boot") },
    ];

    let in_my_size = shoes_in_my_size(shoes, 10);

    assert_eq!(
        in_my_size,
        vec![
            Shoe { size: 10, style: String::from("sneaker") },
            Shoe { size: 10, style: String::from("boot") },
        ]
    );
}
```

<span class="caption">Листинг 13-19: Использование метода <code>filter</code> вместе с замыканием, которое захватывает параметр <code>shoe_size</code></span>

Функция `shoes_in_my_size` принимает в качестве параметров вектор из обуви (shoes) и размер обуви (shoe_size). Возвращает вектор, содержащий только туфли указанного размера.

В теле `shoes_in_my_size` мы вызываем `into_iter` для создания итератора, который становится владельцем вектора. Затем мы вызываем `filter`, чтобы адаптировать текущий итератор в новый итератор, содержащий только те элементы, для которых замыкание возвращает `true`.

Замыкание захватывает параметр `shoe_size` из окружения и сравнивает его значение с размером каждого предмета, сохраняя только обувь указанного размера. Наконец, вызов `collect` собирает значения, возвращённые адаптированным итератором в вектор, возвращаемый функцией.

Тест показывает, что когда мы вызываем `shoes_in_my_size`, мы получаем только ту обувь, размер которой равен указанному значению.

### Создание собственных итераторов с помощью типажа `Iterator`

Мы показали, что можно создать итератор, вызывая методы `iter`, `into_iter` или `iter_mut` у вектора. Вы можете создавать итераторы из других типов коллекций стандартной библиотеки, таких как хеш-карта. Вы также можете создавать итераторы, которые делают все, что вы хотите, реализуя типаж `Iterator` для ваших собственных типов. Как упоминалось ранее, единственный метод для которого требуется предоставить определение - это метод `next`. Сделав это, можно использовать все другие методы, которые имеют реализации по умолчанию, предоставляемые типажом `Iterator`!

Чтобы продемонстрировать, давайте создадим итератор, который будет считать только от 1 до 5. Во-первых, мы создадим структуру для хранения некоторых значений. Затем мы превратим эту структуру в итератор, реализовав типаж `Iterator` и используя значения в этой реализации.

Листинг 13-20 определяет структуру `Counter` и ассоциированную функцию `new`, создающую экземпляры структуры `Counter`:

<span class="filename">Файл: src/lib.rs</span>

```rust
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}
```

<span class="caption">Листинг 13-20: Определение структуры <code>Counter</code> и функции <code>new</code>, которая создаёт экземпляр структуры <code>Counter</code> с начальным значением 0 поля <code>count</code></span>

Структура `Counter` имеет одно поле с именем `count`. Это поле хранит значение `u32`, которое будет отслеживать где мы находимся в процессе итерации от 1 до 5. Поле `count` является приватным, поскольку мы хотим, чтобы реализация `Counter` контролировала его значение. Функция `new` обеспечивает желаемое поведение, чтобы всегда инициализировать новые экземпляры значением 0 в поле `count`.

Далее, мы реализуем типаж `Iterator` для структуры `Counter`, определив тело метода `next`, реализуя то, что хотим получить при использовании этого итератора, как это показано в листинге 13-21:

<span class="filename">Файл: src/lib.rs</span>

```rust
# struct Counter {
#     count: u32,
# }
#
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        self.count += 1;

        if self.count < 6 {
            Some(self.count)
        } else {
            None
        }
    }
}
```

<span class="caption">Листинг 13-21: Реализация типажа <code>Iterator</code> у структуры <code>Counter</code></span>

Мы указываем связанный тип `Item` для нашего итератора как `u32`, то есть итератор возвращает значения `u32`. Опять же, пока не беспокойтесь о ассоциированных типах, мы рассмотрим их в главе 19.

Мы хотим, чтобы наш итератор добавил 1 в текущее состояние, поэтому мы инициализировали `count` в 0, так чтобы он сначала вернул 1. Если значение `count` меньше 6, `next` вернёт текущее значение, заключённое в `Some`, но если `count` равно 6 или больше, наш итератор вернёт `None`.

#### Использование у `Counter` метода итератора `next`

Как только мы реализовали типаж `Iterator`, у нас есть итератор! В листинге 13-22 показан тест, демонстрирующий  использование функциональности итератора нашей структуры `Counter`, вызывая метод `next` непосредственно у неё, как мы это делали с созданным итератором из вектора в листинге 13-15.

<span class="filename">Файл: src/lib.rs</span>

```rust
# struct Counter {
#     count: u32,
# }
#
# impl Iterator for Counter {
#     type Item = u32;
#
#     fn next(&mut self) -> Option<Self::Item> {
#         self.count += 1;
#
#         if self.count < 6 {
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
#
#[test]
fn calling_next_directly() {
    let mut counter = Counter::new();

    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), Some(4));
    assert_eq!(counter.next(), Some(5));
    assert_eq!(counter.next(), None);
}
```

<span class="caption">Листинг 13-22: Тестирование реализации метода <code>next</code></span>

Тест создаёт экземпляр структуры `Counter` в переменной `counter`, затем вызывает метод `next`, проверяя реализацию необходимого поведения итератора: возвращение чисел от 1 до 5.

#### Использование других методов типажа `Iterator`

Мы реализовали типаж `Iterator`, определив метод `next`, поэтому теперь мы можем использовать реализации по умолчанию для любых методов типажа `Iterator`, как определено в стандартной библиотеке, потому что все они используют функциональность метода `next`.

Например, если по какой-то причине мы хотели взять значения, созданные экземпляром `Counter`, сопоставить их со значениями, созданными другим экземпляром `Counter` пропуская первое значение, перемножить каждую пару друг с другом, сохраняя только те результаты, которые делятся на 3 и складывая все полученные значения вместе, мы могли бы сделать это так, как показано в тесте листинга 13-23:

<span class="filename">Файл: src/lib.rs</span>

```rust
# struct Counter {
#     count: u32,
# }
#
# impl Counter {
#     fn new() -> Counter {
#         Counter { count: 0 }
#     }
# }
#
# impl Iterator for Counter {
#     // Our iterator will produce u32s
#     type Item = u32;
#
#     fn next(&mut self) -> Option<Self::Item> {
#         // increment our count. This is why we started at zero.
#         self.count += 1;
#
#         // check to see if we've finished counting or not.
#         if self.count < 6 {
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
#
#[test]
fn using_other_iterator_trait_methods() {
    let sum: u32 = Counter::new().zip(Counter::new().skip(1))
                                 .map(|(a, b)| a * b)
                                 .filter(|x| x % 3 == 0)
                                 .sum();
    assert_eq!(18, sum);
}
```

<span class="caption">Листинг 13-23: Использование множества методов типажа <code>Iterator</code> в пользовательском итераторе <code>Counter</code></span>

Обратите внимание, что `zip` возвращает только четыре пары; теоретическая пятая пара `(5, None)` никогда не создаётся, поскольку `zip` возвращает `None` тогда, когда любой из его входных итераторов возвращает значение `None`.

Все эти вызовы методов возможны, потому что мы указали, как работает метод `next`, а стандартная библиотека предоставляет реализации по умолчанию для всех других методов, которые внутри вызывают `next`.
