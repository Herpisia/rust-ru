# Игра "Угадай число"

Давайте начнём программирование с Rust, работая вместе над практическим проектом! Эта глава ознакомит вас с некоторыми базовыми концепции языка Rust, показывая их применение в реальной программе.
Вы узнаете про `let`, `match`, методы, ассоциированные функции, использование внешних пакетов и многое другое! Последующие главы расскажут про эти идеи более детально. В этой главе Вы будете практиковать основы.

Мы реализуем классическую программу для начинающих: угадывание числа. Вот как это работает: программа генерирует случайное целое число от 1 до 100. Затем она предлагает игроку ввести и отгадать число. Если оно больше или меньше предложенного игроком, то  программа сообщит об этом. Если игрок угадал число, то программа выведет поздравление и завершится.

## Настройка нового проекта

Для создания нового проекта, в строке терминала перейдите в папку *projects*, которую вы создали в главе 1. С помощью уже знакомой Вам утилиты `cargo` создайте новый проект:

```text
$ cargo new guessing_game
$ cd guessing_game
```

Первая команда, `cargo new` принимает в качестве первого аргумента имя нового проекта (`guessing_game`). Вторая команда изменяет текущий каталог на директорию проекта.

Посмотрите на созданный файл *Cargo.toml*:

<span class="filename">Файл: Cargo.toml</span>

```toml
[package]
name = "guessing_game"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]
edition = "2018"

[dependencies]
```

Если информация про авторов, которую Cargo берёт из вашей среды неправильна, исправьте её в файле и сохраните.

Как вы уже видели в главе 1, `cargo new` генерирует 
программу "Hello, world!". Посмотрите файл *src/main.rs*:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

Давайте теперь скомпилируем эту программу и запустим её с помощью команды `cargo run`:

```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/guessing_game`
Hello, world!
```

Команда `run` полезна, когда нужно быстро скомпилировать и запустить программу на выполнение. Например в этой игре мы будем тестировать каждую часть перед переходом к следующей.

Откройте файл *src/main.rs*. Вы будете набирать код в этом файле.

## Обработка вводимых данных

Первая часть игры будет запрашивать пользователя ввести данные, обрабатывать эти данные и проверять их на соответствие условиям задачи. Для начала, мы позволим игроку ввести число. Введите код из листинга 2-1 в файл *src/main.rs*:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```

<span class="caption">Листинг 2-1: Программа просит ввести догадку, а потом печатает её</span>

Этот код содержит много информации, так что давайте разберём его построчно. Чтобы получить пользовательский ввод и затем вывести результат, мы должны подключить библиотеку `io` (input/output) в область видимости проекта. Библиотека `io` подключается из стандартной библиотеки (которая известна как `std`):

```rust,ignore
use std::io;
```

По умолчанию, Rust автоматически подключает несколько типов данных в область видимости каждой программы ([*авто-импорт - prelude*](https://doc.rust-lang.org/std/prelude/index.html))<comment>. Если типы данных, которые вы хотите использовать в программе не входят в авто-импорт, то вам нужно подключить их в область видимости явно. Это можно сделать с помощью выражения <code data-md-type="codespan">use</code>. Библиотека ввода/вывода <code data-md-type="codespan">std::io</code> предоставляет множество полезных функциональных возможностей, включая обработку вводимых данных пользователя.</comment>

Как вы видели в главе 1, функция `main` является точкой  начала выполнения программы:

```rust,ignore
fn main() {
```

Ключевое слово `fn` объявляет новую функцию, круглые скобки `()` показывают что у функции нет параметров, фигурная скобка `{` - обозначение начала тела функции.

Как вы уже узнали из главы 1, макрос `println!` выводит строку на экран:

```rust,ignore
println!("Guess the number!");

println!("Please input your guess.");
```

Этот код печатает подсказку с указанием игры и приглашает пользователя ввести число.

### Хранение данных с помощью переменных

Далее, мы создаём место хранения введённых игроком данных:

```rust,ignore
let mut guess = String::new();
```

Теперь программа становится интересней. В этой маленькой строчке происходит много всего. Прежде всего здесь есть выражение `let`, которое используется для создания *переменной*. Вот, например:

```rust,ignore
let foo = bar;
```

В этой строке создаётся переменная с именем `foo`, которая связывается со значением из переменной `bar`. Особенностью языка Rust является то, что переменные по умолчанию неизменяемые. Мы рассмотрим эту концепцию более детально в разделе [“Переменные и понятие изменяемости”](ch03-01-variables-and-mutability.html#variables-and-mutability)<comment> главы 3. Предложенный пример показывает, как использовать ключевое слово <code data-md-type="codespan">mut</code> перед именем переменной
для того, чтобы сделать переменную изменяемой.</comment>

```rust,ignore
let foo = 5; // НЕизменяемая - immutable
let mut bar = 5; // изменяемая - mutable
```

> Обратите внимание, что символы `//` - синтаксис, обозначающий комментарий,
> который размещается на одной строке. Rust игнорирует всё, что размещено в строке комментария. Более подробно см. в главе № 3.

Давайте вернёмся к нашей программе. Теперь вы знаете, что `let mut guess` создаст изменяемую переменную с именем `guess`. С другой стороны от знака равенства ( `=` ) находится значение, к которому `guess` будет привязано и что является результатом вызова функции `String::new`. Эта функция возвращает новый экземпляр типа данных `String` .<a href="../std/string/struct.String.html" data-md-type="link">`String`</a> <comment> </comment> - строковый тип, предоставляемый стандартной библиотекой, который является строкой текста в формате UTF-8, с возможностью увеличения размера.

Синтаксис `::` в строке `::new` показывает что `new` является *ассоциированной функцией* для типа `String`. Ассоциированные функции реализуются в каком-либо типе, в данном случае в `String`, а не в экземпляре `String`. В некоторых языках это называется *статической функцией*.

Данная функция `new` создаёт новую пустую строку. Вы можете найти функцию `new` у многих типов, потому что это распространённое имя для функции, которая создаёт какое-то новое значение.

Подытожим, строка `let mut guess = String::new();` создаёт изменяемую переменную, которая привязывается к пустому новому экземпляру `String`. Ух ты!

Напомним, что мы подключили функции ввода-вывода из стандартной библиотеки с помощью `use std::io;` в первой строчке программы. Теперь мы вызовем функцию `stdin` из модуля `io`:

```rust,ignore
io::stdin().read_line(&mut guess)
    .expect("Failed to read line");
```

Если бы мы не добавили строку`use std::io` в начало программы, мы смогли бы вызвать эту функцию как `std::io::stdin`. Функция `stdin` возвращает экземпляр [`std::io::Stdin`], который является типом, предоставляющим обработку стандартного ввода из Вашего терминала.

Следующая часть кода, `.read_line(&mut guess)`, вызывает метод [`read_line`] обработчика стандартного ввода для получения данных от пользователя. Мы передаём в функцию `read_line` один аргумент: `&mut guess`.

Работа функции `read_line` состоит в чтении пользовательского ввода из стандартного потока ввода и размещение этих данных в строке, которая была передана как аргумент. Строковый аргумент должен быть изменяемым, чтобы метод мог изменить содержание строки добавлением данных вводимых пользователем.

Символ `&` показывает, что аргумент является *ссылкой*, которая даёт возможность получить доступ к данным в нескольких местах кода без необходимости копировать эти данные в памяти несколько раз. Ссылки - это сложная особенность и одно из главных преимуществ Rust, безопасность и лёгкость использования ссылок. Вам не нужно знать массу деталей для завершения этой программы. В данный момент нужно знать, что ссылки по умолчанию являются неизменяемыми. Следовательно, необходимо написать `&mut guess`, а не `&guess`, чтобы сделать ссылку изменяемой. (Глава 4 объясняет ссылки более тщательно.)

### Обработка потенциальных ошибок с помощью типа `Result`

Мы не совсем закончили с разбором этой строки кода. Хотя то, что мы обсуждали является одной строкой текста, это первая часть одной логической строки кода. Вторая часть это следующий метод:

```rust,ignore
.expect("Failed to read line");
```

Когда вы вызываете метод с синтаксисом `.foo()`, часто следует добавить перевод строки и пробелы, чтобы разбить длинные строки на логические части. Мы можем переписать этот код так:

```rust,ignore
io::stdin().read_line(&mut guess).expect("Failed to read line");
```

Тем не менее, одна строка читается сложнее, поэтому лучшим решением будет разделить её: две строки для двух вызовов функций. Давайте теперь объясним, что эта строка делает.

Как упоминалось ранее, `read_line` помещает символы  пользовательского ввода в переменную переданную в неё, но она также имеет возвращаемый тип - в этом случае это `io::Result`. Rust в стандартной библиотеке имеет несколько типов с именем `Resul`: обобщённый тип `Result`, а также конкретные версии для подмодулей, такие как `io::Result`.

Типы `Result` являются [*перечислениями*]<comment>, часто называемые <em data-md-type="emphasis">enums</em>. Перечисление имеет фиксированное множество возможных значений, которые называются <em data-md-type="emphasis">вариантами</em> перечисления. Глава 6 рассмотрит перечисления более детально.</comment>

Для `Result` существуют варианты `Ok` или `Err`. Вариант `Ok` показывает, что операция прошла успешно и внутри `Ok`находится успешно созданное значение. Вариант `Err` означает, что операция провалилась и `Err` содержит информацию, почему это произошло.

Назначение типа `Result` состоит в кодировании информации для обработки ошибки.
Значения типа`Result`, как и значения любых типов, имеют определённые в них методы. Экземпляр `io::Result` имеет [`expect` метод], который можно вызвать. Если экземпляр `io::Result` является значением `Err`, то метод `expect` вызовет сбой программы и покажет сообщение, которое Вы передали как аргумент в `expect`. Если метод `read_line` вернёт `Err`, это вероятно будет ошибка, происходящая от операционной системы. Если экземпляр `io::Result` будет `Ok`, `expect` возьмёт и вернёт значение содержащееся внутри `Ok`, чтобы его можно было использовать. В этом случае, значением будет число байт, которые пользователь ввёл в стандартный поток ввода.

Если Вы не вызовете `expect`, программа скомпилируется, но Вы получите предупреждение:

```text
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `std::result::Result` which must be used
  --> src/main.rs:10:5
   |
10 |     io::stdin().read_line(&mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(unused_must_use)] on by default
```

Rust предупреждает, что вы не используете значение `Result` возвращённое из `read_line`, показывая что программа не обрабатывает возможную ошибку.

Правильным способом убрать предупреждение будет обработать ошибку, но так как Вы хотите чтобы программа завершилась, Вы можете использовать `expect`. Вы узнаете про восстановление после ошибок в главе 9.

### Вывод значений с помощью `println!`

Помимо закрывающих фигурных скобок присутствует ещё одна строка которую нужно обсудить:

```rust,ignore
println!("You guessed: {}", guess);
```

Эта строка выведет строку, в которую сохранён ввод пользователя. Фигурные скобки `{}` являются заполнителем: думайте о  `{}` как о маленьком крабе, в клешнях которого находится значение. Вы можете вывести больше одного значения используя фигурные скобки: первые скобки держат первое значение перечисленное после форматируемой строки, вторые скобки держат второе значение, и так далее. Печать нескольких значений одним вызовом макроса `println!` выглядит так:

```rust
let x = 5;
let y = 10;

println!("x = {} and y = {}", x, y);
```

Этот код выведет `x = 5 and y = 10`.

### Тестирование первой части

Давайте протестирует первую часть игры. Запустите её используя `cargo run`:

```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```

На данный момент первая часть игры завершена: мы получаем ввод с клавиатуры и затем выводим его.

## Генерация секретного числа

Далее нам нужно сгенерировать секретное число, которое пользователь попробует угадать. Секретное число должно быть все время разным, так как в игру можно играть много раз. Давайте будем использовать случайное число от 1 до 100, чтобы не делать игру слишком сложной. Rust пока не включает случайную генерацию чисел в стандартную библиотеку. Тем не менее, команда Rust предоставляет [крейт`rand`].

### Использование крейта для получения дополнительных функций

Напомним, что крейт является собранием файлов исходного кода Rust. Проект который мы собираем является *бинарным крейтом*, который исполняемый.
Крейт `rand` это *библиотека*, которая содержит код, предназначенный для использования в других программах.

Использование внешних крейтов Cargo это то в чем он блистает. Перед тем как мы сможем написать код использующий `rand`, нужно изменить файл *Cargo.toml* для подключения крейта `rand` в качестве зависимости. Откройте этот файл и добавьте предложенную строку под заголовком секции `[dependencies]` созданную Cargo для Вас:

<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->

<span class="filename">Файл: Cargo.toml</span>

```toml
[dependencies]
rand = "0.5.5"
```

Все что следует за заголовком в файле *Cargo.toml* является частью раздела, продолжающегося до следующего заголовка. Секция `[dependencies]` указывает Cargo какие внешние крейты и какие их версии нужны в проекте. В данном случае мы пишем крейт `rand` с указанием версии `0.5.5`. Cargo понимает [семантическое версионирование]<comment> (иногда называемое <em data-md-type="emphasis">SemVer</em>), которое является стандартом для записи номеров версий. Число `0.5.5` является укороченной версией <code data-md-type="codespan">^0.5.5</code>, которая подразумевает “любая версия которая имеет публичный API совместимый с версией 0.5.5.”</comment>

Давайте теперь соберём наш проект без каких-либо правок кода, как показано в листинге 2-2.

```text
$ cargo build
    Updating crates.io index
  Downloaded rand v0.5.5
  Downloaded libc v0.2.62
  Downloaded rand_core v0.2.2
  Downloaded rand_core v0.3.1
  Downloaded rand_core v0.4.2
   Compiling rand_core v0.4.2
   Compiling libc v0.2.62
   Compiling rand_core v0.3.1
   Compiling rand_core v0.2.2
   Compiling rand v0.5.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 s
```

<span class="caption">Листинг 2-2: Вывод работы команды <code>cargo build</code> после добавления пакета rand в зависимости</span>

Можно увидеть разные номера версий (но все они будут совместимы с кодом, спасибо SemVer!) и строки могут быть в другом порядке.

Теперь, когда у нас есть внешняя зависимость, Cargo выбирает последние версии всех крейтов из *реестра*, который является копией данных из [Crates.io] . Crates.io - то место, где люди в экосистеме Rust размещают проекты с открытым исходным кодом для других.

После обновления реестра Cargo проверяет раздел `[dependencies]` и загружает любые крейты, которых у вас ещё нет. В этом случае, хотя мы только перечислили только `rand` в качестве зависимости, но Cargo также забрал `libc` и `rand_core`, потому что работа `rand` зависит от них. После загрузки крейтов, Rust компилирует сначала их и затем компилирует проект с доступными зависимостями.

Если вы сразу же запустите `cargo build` без изменений, то не получите никакого вывода кроме строки `Finished`. Cargo знает, что зависимости скачаны и скомпилированы и вы ничего не изменили в вашем файле *Cargo.toml*. Cargo также знает, что вы не изменили что-либо в коде, так что он также не будет компилировать снова. Так как нечего делать, он просто выходит.

Если *открыть* файл *src/main.rs*  и внести простое изменение, сохранить его и собрать снова, то вы увидите только две строки вывода:

```text
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
```

Эти строки показывают, что Cargo обновляет только сборку с вашими небольшими изменениями в файле *src/main.rs*. Остальные зависимости не изменились, поэтому Cargo знает, что может
использовать то, что он уже скачал и скомпилировал ранее. Он просто пересобирает часть кода.

#### Обеспечение воспроизводимых сборок с помощью *Cargo.lock* файла

В Cargo есть механизм, гарантирующий возможность пересобрать тот же артефакт, когда вы или кто-то другой каждый раз собираете код: Cargo будет использовать только указанные вами версии зависимостей, пока не укажете другие. Например, что произойдёт, если на следующей неделе выйдет крейт `rand` с версией 0.5.6, содержащей исправление важной ошибки, но который также содержит регрессию, которая сломает ваш код?

Ответом на эту проблему является файл *Cargo.lock*, который создаётся впервые при запуске `cargo build` и потом находится в вашем каталоге *guessing_game*. Когда вы впервые собираете проект, Cargo выясняет все версии зависимостей, которые соответствуют критериям, а затем записывает их в файл *Cargo.lock*. Когда в будущем вы будете собирать проект, то Cargo увидит, что файл *Cargo.lock* существует и будет использовать указанные там версии вместо того, чтобы делать всю работу по выяснению версий снова. Это позволяет иметь воспроизводимую сборку автоматически. Другими словами, ваш проект будет оставаться на уровне версии `0.5.5` благодаря *Cargo.lock* файлу, пока не обновите версию явно.

#### Обновление крейта для получения новой версии

Когда вы *хотите* обновить крейт, Cargo предоставляет другую команду, `update`, которая проигнорирует файл *Cargo.lock* и выяснит все последние версии, которые соответствуют вашим спецификациям в *Cargo.toml* файле. Если это работает, Cargo напишет эти версии в файл *Cargo.lock*.

Но по умолчанию Cargo будет искать только версии больше `0.5.5` и меньше, чем `0.6.0` . Если `rand` крейт выпустил две новые версии, `0.5.6` и `0.6.0` , вы увидите следующее при запуске `cargo update` :

```text
$ cargo update
    Updating crates.io index
    Updating rand v0.5.5 -> v0.5.6
```

В этот момент вы также заметите изменение в файле *Cargo.lock*, отметив что версия крейта `rand`, которую вы сейчас используете является `0.5.6` .

Если вы хотите использовать крейт `rand` версии `0.6.0` или любую версию в `0.6.x`, то для этого нужно будет обновить файл *Cargo.toml*, чтобы он выглядел следующим образом:

```toml
[dependencies]
rand = "0.6.0"
```

В следующий раз при запуске `cargo build`, Cargo обновит реестр доступных крейтов и пересмотрит ваши требования к `rand` в соответствии с новой версией, которую вы указали.

Можно много рассказать про [Cargo] и его экосистему которые мы обсудим в главе 14, сейчас это все что вам нужно знать. Cargo позволяет очень легко повторно использовать библиотеки, поэтому Rust разработчики имеют возможность писать меньшие проекты, которые скомпонованы из многих пакетов.

### Генерация случайного числа

Теперь, когда вы добавили `rand` крейт в *Cargo.toml*, давайте начнём использовать `rand`. Следующим шагом является обновление *src/main.rs*, как показано в листинге 2-3.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```

<span class="caption">Листинг 2-3: Добавление кода для генерации случайного числа</span>

Сначала, добавим `use` строку вида: `use rand::Rng`. Крейт `Rng` определяет методы, которые реализуют генератор случайных чисел и данный типаж должен быть в области видимости, чтобы использовать его методы. Глава 10 подробно расскажет об типажах.

Далее добавляем две строки по середине. Функция `rand::thread_rng` предоставит генератор случайных чисел, который мы собираемся использовать: тот, который является локальным для текущего потока выполнения и инициализирован операционной системой. Затем мы вызываем метод `gen_range` у генератора случайного числа. Этот метод объявлен в типаже `Rng`, который мы импортировали в область действия оператором `use rand::Rng`. Метод `gen_range` принимает два числа в качестве аргументов и генерирует случайное число в их диапазоне. Он включает нижнюю границу, но исключает верхнюю границу, поэтому нам нужно указать `1` и `101` чтобы запросить число от 1 до 100.

> Примечание: вы не будете знать, какие типажи использовать, какие методы и функции вызывать из крейта. Инструкции по использованию крейта есть в каждой документации. Ещё одна полезная особенность Cargo - то, что вы можете запустить команду `cargo doc --open`, которая соберёт локальную документацию, предоставленную всеми зависимостями и откроет её в браузере. Если вы заинтересованы в других функциях крейта `rand`, например, запустите `cargo doc --open` и нажмите `rand` на боковой панели слева.

Вторая строка, которую мы добавили в середину кода, печатает секретное число. Она полезна, когда при разработке программы, чтобы иметь возможность её тестировать, но мы удалим её из окончательной версии. Это не интересная игра, если программа сразу печатает ответ при запуске!

Попробуйте запустить программу несколько раз:

```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
$ cargo run
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
```

Вы должны получить разные случайные числа, и все они должны быть числами между 1 и 100. Отличная работа!

## Сравнение догадки с секретным числом

Теперь, когда у нас есть пользовательский ввод и случайное число, можно сравнить их. Этот шаг показан в листинге 2-4. Обратите внимание, что этот код ещё не компилируется, мы объясним.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {

    // ---snip---

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}
```

<span class="caption">Листинг 2-4. Обработка возможных возвращаемых значений сравнивая два числа</span>

Первый новый код здесь - это ещё один оператор `use`, импортирующий в область видимости тип с именем `std::cmp::Ordering` из стандартной библиотеки. Как `Result`, тип `Ordering` - это ещё одно перечисление, но вариантами для `Ordering` являются `Less`, `Greater` и `Equal`. Это три результата, которые возможны при сравнении двух значений.

Затем мы добавляем пять новых строк внизу, которые используют тип `Ordering`. Метод `cmp` сравнивает два значения и может быть вызван на чем угодно, что можно сравнивать. Метод принимает ссылку на то, с чем вы хотите сравнить: здесь мы сравниваем `guess` с `secret_number`. Затем он возвращает вариант `Ordering` перечисления присутствующий в области видимости благодаря `use`. Используется [`match`] выражение для решения, что делать дальше на основе полученного варианта `Ordering` из вызова `cmp` со значениями в `guess` и `secret_number`.

Выражение `match` состоит из *рукавов*. Рукав состоит из *шаблона* и кода, который должен быть запущен, если значение заданное в начале выражение `match` соответствует образцу этого рукава. Rust берёт значение, указанное для `match` и просматривает каждый рукав по очереди. Конструкция `match` и шаблоны являются мощными функциями в Rust, которые позволяют выразить различные ситуации, которые могут встретиться в коде и убедится, что все они обработаны. Эти особенности будут подробно рассмотрены в главе 6 и главе 18 соответственно.

Давайте разберём пример того, что случилось бы с использованным здесь выражением `match`. Скажем, пользователь угадал 50 и случайно сгенерированное секретное число на этот раз равно 38. Когда код сравнивает 50 с 38, метод `cmp` вернёт `Ordering::Greater`, потому что 50 больше 38. Выражение `match` получает значение `Ordering::Greater` и начинает проверять каждый рукав шаблонов. Он смотрит на шаблон первого рукава, `Ordering::Less`, и видит, что значение `Ordering::Greater` не соответствует `Ordering::Less`, поэтому игнорируется код в этом рукаве и переходит к следующему рукаву. Образец следующего рукава, `Ordering::Greater`, шаблон *совпадает* с `Ordering::Greater`! Связанный с рукавом код выполняется и напечатает `Too big!` на экран. Выражение `match`  заканчивается, потому что нет необходимости смотреть на последний рукав в этом сценарии.

Однако код в листинге 2-4 ещё не компилируется. Давайте попробуем:

```text
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --> src/main.rs:23:21
   |
23 |     match guess.cmp(&secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integer
   |
   = note: expected type `&std::string::String`
   = note:    found type `&{integer}`

error: aborting due to previous error
Could not compile `guessing_game`.
```

Суть ошибки состоит в том, что существуют *не совпадающие типы*. В Rust имеется строгая, статическая система типов. Тем не менее, он также имеет выведение типов. Когда мы написали `let mut guess = String::new()`, Rust смог сделать вывод, что `guess` должен быть `String` и не заставил нас писать тип. Но переменная `secret_number` это также числовой тип с другой стороны. Некоторые числовые типы могут иметь значения от 1 до 100: 32-битное знаковое число `i32`; 32-битное без знаковое число `u32`; 64-битное знаковое `i64`; а также другие. Rust по умолчанию использует `i32`, который является типом для `secret_number`, если вы не добавите информацию о типе в другом месте, что заставит Rust вывести другой числовой тип. Причина ошибки в том, что Rust не может сравнить строковый тип и числовой.

В конечном счёте, мы хотим преобразовать считываемые программой `String` из стандартного ввода в тип действительного числа, чтобы было можно сравнивать его в числовом виде с загаданным числом. Можно это сделать, добавив следующие две строки в тело `main` функции:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
// --snip--

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse()
        .expect("Please type a number!");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}
```

Две новые строки:

```rust,ignore
let guess: u32 = guess.trim().parse()
    .expect("Please type a number!");
```

Мы создаём переменную с именем `guess`. Но подождите, разве в программе уже нет переменной с именем `guess`? Да это так, но Rust позволяет нам *затенять* предыдущее значение `guess` с помощью нового. Эта функция часто используется в ситуациях где вы хотите преобразовать значение из одного типа в другой. Затенение позволяет повторно использовать имя переменной `guess`, а не заставлять нас создавать две уникальные переменные, вроде `guess_str` и `guess`. (Глава 3 охватывает затенение более подробно.)

Мы связываем `guess` с выражением `guess.trim().parse()`. Переменная `guess` в выражении ссылается на исходную переменную `guess` которая была типа `String` при вводе данных. Метод `trim` на экземпляре `String` удалит все пробелы в начале и конце. Хотя `u32` может содержать только числовые символы, пользователь должен нажать <span class="keystroke">Enter</span>, чтобы удовлетворить метод `read_line`. Когда пользователь нажимает <span class="keystroke">ввод</span>, символ новой строки добавляется в строку. Например, если пользователь вводит <span class="keystroke">5</span> и нажимает <span class="keystroke">ввод</span>, `guess` выглядит так: `5\n`. Символ `\n` представляет символ «новая строка» как результат нажатия <span class="keystroke">ввода</span>. Метод `trim` исключает `\n`, в результате получаем `5`.

Метод [`parse` у строк ] разбирает строку в число некоторого типа. Поскольку этот метод может анализировать различные типы чисел, то нужно указать точный тип числа, который мы хотим получить с помощью `let guess: u32`. Двоеточие (`:`) после `guess`, говорит Rust что мы аннотировали тип переменной. Rust имеет несколько встроенных числовых типов; здесь вы видите `u32` являющийся 32-битным без знаковым целым числом. Это хороший выбор по умолчанию для небольшого положительного числа. Вы узнаете о других типах чисел в главе 3. Кроме того, аннотация `u32` в этом примере программы и сравнение с `secret_number` означает, что Rust
выведет что `secret_number` должен иметь тип `u32`. Так что теперь сравнение будет между двумя значениями одного типа!

Вызов метода `parse` может легко вызвать ошибку. Если, например, строка содержит `A👍%` , то нет никакого способа преобразовать его в число. Так как вызов `read_line` может дать сбой, то метод `parse` возвращает тип `Result`, так же как `read_line` метод (обсуждался ранее в “Обработка потенциального сбоя с помощью `Result` типа"). Мы будем обрабатывать этот `Result` снова, используя метод `expect`. Если `parse` возвращает вариант `Err` перечисления `Result`, потому что он не может создать число из строки, то вызов `expect` приведёт к сбою игры и распечатает сообщение, которое мы передали в него. Если `parse` сможет успешно преобразовать строку в число, он вернёт перечисления `Result` с вариантом Ok, а expect вернёт
число, которое мы хотим от значения Ok.

Давайте запустим программу сейчас!

```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
```

Хорошо! Несмотря на то, что были добавлены пробелы перед догадкой, программа все равно вывела пользовательское предположение 76. Запустите программу несколько раз для проверки разного поведение с разными видами ввода: догадка правильная, догадка слишком велика и слишком мала.

Большая часть игры сейчас работает, но пользователь может сделать только одно предположение. Давайте изменим это, добавив цикл!

## Разрешение нескольких догадок с помощью цикла

Ключевое слово `loop` создаёт бесконечный цикл. Мы добавим его сейчас, чтобы дать пользователям больше шансов угадать число:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
// --snip--

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        // --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => println!("You win!"),
        }
    }
}
```

Как видите, мы переместили весь код вывода подсказки и ввода догадки в цикл. Обязательно сделайте отступ в строках внутри цикла по четыре пробела на каждой строке и снова запустите программу. Обратите внимание, что есть новая проблема, потому что программа выполняет именно то, что мы ей написали: запрашивает новую догадку до бесконечности! Похоже, что пользователь не сможет выйти!

Пользователь всегда может прервать программу, используя сочетание клавиш <span class="keystroke">ctrl-c</span> . Но есть ещё один способ избежать этого, как упоминалось в обсуждении `parse` раздела ["Сравнение догадки секретный номер"”](#comparing-the-guess-to-the-secret-number)<comment> : если пользователь вводит не числовой ответ, программа завершится сбоем. Пользователь может воспользоваться этим, чтобы выйти, как показано здесь:</comment>

```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/guess` (exit code: 101)
```

Ввод `quit` в самом деле завершит игру, как и любой другой ввод не являющийся числом. Однако это не оптимально, если не сказать больше. Мы хотим, чтобы игра автоматически остановитесь, когда угадан правильный номер.

### Выход после правильной догадки

Давайте запрограммируем игру на выход при выигрыше пользователя, добавив оператор `break` :

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
// --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```

Добавление строки `break` после `You win!` заставляет программу выходить из цикла, когда пользователь правильно угадывает число. Выход из цикла также означает выход из программы, потому что цикл является последней частью `main` .

### Обработка неверного ввода

Для дальнейшего улучшения поведения игры вместо аварийного завершения программы при вводе пользователем не числовых значений, давайте заставим игру игнорировать не число, поэтому пользователь может продолжать угадывать. Можно сделать это, изменив строку, где `guess` преобразуется из `String` в `u32`, как показано в листинге 2-5.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
// --snip--

io::stdin().read_line(&mut guess)
    .expect("Failed to read line");

let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};

println!("You guessed: {}", guess);

// --snip--
```

<span class="caption">Листинг 2-5. Игнорирование догадки не являющейся числом и запрос другого предположения вместо сбоя программы</span>

Переключение с вызова `expect` на вызов выражения `match` как правило является способом перейти от сбоя при ошибке к обработке ошибки. Помните, что `parse` возвращает тип `Result` а `Result` - это перечисление с вариантами `Ok` или `Err`. Мы здесь используем выражение `match`, как мы это делали с результатом `Ordering` метода `cmp` .

Если `parse` может успешно превратить строку в число, он вернёт значение `Ok` , которое содержит полученное число. Значение `Ok` будет соответствовать шаблону первого рукава, и выражение `match` просто вернёт `num` значение, которое возвращает метод `parse` и поместит это значение внутрь `Ok` перечисления. Это число окажется в нужном месте, в новой созданной переменной `guess`.

Если метод `parse` *не* способен превратить строку в число, он вернёт значение `Err` , которое содержит более подробную информацию об ошибке. Значение `Err` не соответствует `Ok(num)` шаблону в первом `match` рукаве, но оно соответствует шаблону `Err(_)` во втором рукаве. Подчёркивание, `_`, является шаблоном обработки всех остальных случаев; в данном примере мы говорим, что хотим соответствовать всем значениям `Err` независимо от того, какую информацию они имеют внутри. Так что программа будет выполнять код второго рукава `continue` , что говорит программе перейти к следующей итерации цикла `loop` и запросить другую догадку пользователя. Таким образом, программа  эффективно игнорирует все ошибки , которые `parse` , которые может вернуть!

Теперь все в программе должно работать как положено. Давай попробуем:

```text
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
```

Потрясающе! С помощью небольшого финального улучшения мы закончим игру в догадки. Помните, что программа все ещё печатает загаданный номер. Это хорошо работало для тестирования, но это нарушает игру. Давайте удалим `println!` который выводит загаданное число. Листинг 2-6 показывает окончательный код.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```

<span class="caption">Листинг 2-6: Полный код игры угадывания числа</span>

## Итоги

На данный момент вы успешно создали игру угадай число. Поздравляем!

Этот проект был практическим способом познакомить вас со многими новыми концепциями Rust: `let` , `match` , методы, ассоциированные функции, использование внешних крейтов и другое. В следующих нескольких главах вы узнаете эти понятия более подробно. Глава 3 охватывает концепции, которые есть у большинства языков программирования, такие как переменные, типы данных и функции, а также показывает их использование в Rust. Глава 4 исследует владение, особенность, которая отличает Rust от других языки. В главе 5 обсуждаются структуры и синтаксис методов, а в главе 6 объясняет, как работают перечисления.


[`std::io::Stdin`]: ../std/prelude/index.html
[`read_line`]: ../std/string/struct.String.html
[*перечислениями*]: ../std/io/struct.Stdin.html
[`expect` метод]: ../std/io/struct.Stdin.html#method.read_line
[крейт`rand`]: ../std/io/type.Result.html
[семантическое версионирование]: ../std/result/enum.Result.html
[Crates.io]: ch06-00-enums.html
[Cargo]: ../std/result/enum.Result.html#method.expect
[`match`]: https://crates.io/crates/rand
[`parse` у строк ]: http://semver.org
