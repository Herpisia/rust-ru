# Программируем игру Угадайка

Давайте погрузимся в Rust, вместе выполнив практический проект! Эта глава познакомит с несколькими распространенными концепциями Rust, показав, как использовать их в реальной программе. Вы узнаете о `let`, `match`, методах, ассоциированных функциях, использовании внешних пакетов и многом другом! В следующих главах рассмотрим эти идеи более подробно. В этой главе вы на практике познакомитесь с основами.

Мы реализуем классическую для начинающих программистов задачу: игру угадайку. Вот как это работает: программа генерирует случайное целое число в диапазоне от 1 до 100. Затем она предлагает игроку ввести отгадку. После ввода отгадки программа укажет, является ли отгадка слишком заниженной или слишком завышенной. Если отгадка верна, игра напечатает поздравительное сообщение и завершится.

## Настройка нового проекта

Для настройки нового проекта перейдите в каталог *projects*, который вы создали в главе 1, и создайте новый проект с использованием Cargo, как показано ниже:

```console
$ cargo new guessing_game
$ cd guessing_game
```

Первая команда, `cargo new`, принимает в качестве первого аргумента имя проекта (`guessing_game`). Вторая команда изменяет каталог на новый каталог проекта.

Загляните в созданный файл *Cargo.toml*:

<span class="filename">Имя файла: Cargo.toml</span>

```toml
{{#include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/Cargo.toml}}
```

Как вы уже видели в Главе 1, `cargo new` создаёт программу "Hello, world!". Посмотрите файл *src/main.rs*:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/src/main.rs}}
```

Теперь давайте скомпилируем программу "Hello, world!" и сразу на этом же этапе запустим ее с помощью команды `cargo run`:

```console
{{#include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/output.txt}}
```

Команда `run` пригодится, когда необходимо ускоренно выполнить итерацию проекта, мы так собираемся сделать в этом проекте, быстро тестируя каждую итерацию, прежде чем перейти к следующей.

Снова откройте файл *src/main.rs*. Весь код вы будете писать в этом файле.

## Обработка отгадки

Первая часть программы игры Угадайки запрашивает ввод данных пользователем, обрабатывает их и проверяет, что вводимые данные имеют ожидаемую форму. Для начала мы позволим игроку ввести отгадку. Введите код из Листинга 2-1 в *src/main.rs*.

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:all}}
```

<span class="caption">Листинг 2-1: Код, который получает отгадку от пользователя и печатает ее</span>

Этот код содержит много информации, поэтому давайте рассмотрим его построчно. Чтобы получить пользовательский ввод и затем вывести результат в качестве вывода, нам нужно включить в область видимости библиотеку ввода/вывода `io`. Библиотека `io` является частью стандартной библиотеки, известной как `std`:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:io}}
```

По умолчанию Rust имеет несколько элементов, заданных в стандартной библиотеке, которые он включает в область видимости каждой программы. Этот набор называется *прелюдией (prelude)*, и [в документации по стандартной библиотеке](../std/prelude/index.html) можно увидеть все входящее в ее состав элементы.

Если тип, который требуется использовать, отсутствует в прелюдии, его нужно явно ввести в область видимости с помощью оператора `use`. Использование библиотеки `std::io` предоставляет ряд полезных функциональных возможностей, включая способность принимать пользовательский ввод.

Как уже отмечалось в главе 1, функция `main` является точкой входа в программу:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:main}}
```

Синтаксис `fn` объявляет новую функцию, круглые скобки `()` указывают на отсутствие параметров, а фигурная скобка `{` обозначает начало тела функции.

Также в главе 1 упоминалось, что `println!` - это макрос, который печатает строку на экран:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:print}}
```

Этот код печатает подсказку об игре и запрашивает пользовательский ввод.

### Хранение значений с помощью переменных

Далее мы создаем *переменную* для хранения пользовательского ввода, как показано ниже:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:string}}
```

Вот теперь программа становится интересней! Очень многое происходит в этой маленькой строке. Для создания переменной мы используем оператор `let`. Вот еще один пример:

```rust,ignore
let apples = 5;
```

Эта строка создает новую переменную с именем `apples` и связывает ее со значением 5. В Rust переменные неизменяемые по умолчанию. Мы подробно обсудим эту концепцию в разделе ["Переменные и изменяемость"](ch03-01-variables-and-mutability.html#variables-and-mutability) в главе 3. Чтобы сделать переменную изменяемой, мы добавляем `mut` перед именем переменной:

```rust,ignore
let apples = 5; // неизменяемая
let mut bananas = 5; // изменяемая
```

> Примечание: Синтаксис `//` означает начало комментария, который продолжается до конца строки. Rust игнорирует все содержимое комментариев. Подробнее о комментариях мы поговорим в [главе 3](ch03-04-comments.html).

Возвращаясь к программе игры Угадайка, теперь вы знаете, что `let mut guess` предоставит изменяемую переменную с именем `guess`. Знак равенства (`=`) сообщает Rust, что сейчас нужно связать что-то с этой переменной. Справа от знака равенства находится значение, связанное с `guess`, которое является результатом вызова функции `String::new`, возвращающей новый экземпляр `String`. <a href="../std/string/struct.String.html" data-md-type="link">`String`</a> - это тип строки, предоставляемый стандартной библиотекой, который является расширяемым фрагментом текста в кодировке UTF-8.

Синтаксис `::` в строке `::new` указывает, что `new` является ассоциированной функцией `String` типа. *Ассоциированная функция* - это функция, реализованная для типа, в данном случае `String`. Функция `new` создает новую, пустую строку. Функцию `new` можно встретить во многих типах, это типичное название для функции, которая создает новое значение какого-либо типа.

В целом, строка `let mut guess = String::new();` создала изменяемую переменную, которая связывается с новым, пустым экземпляром `String`. Фух!

### Получение пользовательского ввода

Напомним, мы подключили функциональность ввода/вывода из стандартной библиотеки с помощью `use std::io;` в первой строке программы. Теперь мы вызовем функцию `stdin` из модуля `io`, которая позволит нам обрабатывать пользовательский ввод:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:read}}
```

Если бы мы не импортировали библиотеку `io` с помощью `use std::io` в начале программы, мы все равно могли бы использовать эту функцию, записав вызов этой функции как `std::io::stdin`. Функция `stdin` возвращает экземпляр [`std::io::Stdin`](../std/io/struct.Stdin.html), который является типом, представляющим дескриптор стандартного ввода для вашего терминала.

Далее строка `.read_line(&mut guess)` вызывает метод [`read_line`](../std/io/struct.Stdin.html#method.read_line) на дескрипторе стандартного ввода для получения ввода от пользователя. Мы также передаем `&mut guess` в качестве аргумента `read_line`, сообщая ему, в какой строке хранить пользовательский ввод. Главная задача `read_line` - принять все, что пользователь вводит в стандартный ввод, и сложить это в строку (не переписывая ее содержимое), поэтому мы передаем эту строку в качестве аргумента. Строковый аргумент должен быть изменяемым, чтобы метод мог изменить содержимое строки.

Символ `&` указывает, что этот аргумент является *ссылкой*, который предоставляет возможность нескольким частям вашего кода получить доступ к одному фрагменту данных без необходимости копировать эти данные в память несколько раз. Ссылки - это сложная функциональная возможность, а одним из главных преимуществ Rust является безопасность и простота использования ссылок. Чтобы дописать эту программу, вам не понадобится знать много таких подробностей. Пока вам достаточно знать, что ссылки, как и переменные, по умолчанию неизменяемы. Соответственно, чтобы сделать её изменяемой, нужно написать `&mut guess`, а не `&guess`. (В главе 4 ссылки будут описаны более подробно).

### Обработка потенциального сбоя с помощью типа `Result`

Мы все еще работаем над этой строкой кода. Хотя сейчас мы обсуждаем третью строку текста, это все еще часть одной логической строки кода. Следующей частью является этот метод:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:expect}}
```

Мы могли бы написать этот код так:

```rust,ignore
io::stdin().read_line(&mut guess).expect("Failed to read line");
```

Однако одну длинную строку трудно читать, поэтому лучше разделить ее. При вызове метода с помощью синтаксиса `.method_name()` часто целесообразно вводить новую строку и другие пробельные символы, чтобы разбить длинные строки. Теперь давайте обсудим, что делает эта строка.

Как упоминалось ранее, `read_line` помещает все введенные пользователем данные в переданную ему строку, а также возвращает значение - в данном случае [`io::Result`](../std/io/type.Result.html). В стандартной библиотеке Rust есть несколько типов с именем `Result`: общий <a href="../std/result/enum.Result.html" data-md-type="link">`Result`</a>, а также специальные версии для подмодулей, например `io::Result`. Типы `Result` - это [*перечисления*](ch06-00-enums.html), часто называемые *enums*, имеющие фиксированный набор возможностей, известных как *варианты*. Перечисления часто используются с <code>match</code>, условием, позволяющим выполнять различный код в зависимости от того, какой вариант значения перечисления используется при оценке условия.

В главе 6 перечисления будут рассмотрены более подробно. Назначение всех типов `Result` заключается в передаче информации для обработки ошибок.

Вариантами `Result` являются `Ok` и `Err`. Вариант `Ok` указывает, что операция завершилась успешно, а внутри `Ok` находится успешно сгенерированное значение. Вариант `Err` означает, что операция не удалась, а `Err` содержит информацию о причинах неудачи.

Значения типа `Result`, как и значения других типов, имеют заданные для них методы. Экземпляр `io::Result` имеет метод [`expect`](../std/result/enum.Result.html#method.expect), который можно вызвать. Если данный экземпляр `io::Result` является значением `Err`, `expect` приведет к аварийному завершению программы и отображению сообщения, которое вы передали в качестве аргумента в `expect`. Если метод `read_line` возвращает `Err`, то скорее всего это результат ошибки, исходящей от основной операционной системы. Если данный экземпляр `io::Result` является значением `Ok`, `expect` возьмет возвращаемое значение, содержащееся в `Ok`, и вернет только это значение, чтобы его можно было использовать. В данном случае это значение - количество байтов в пользовательском вводе.

Если не вызвать `expect`, программа скомпилируется, но будет получено предупреждение:

```console
{{#include ../listings/ch02-guessing-game-tutorial/no-listing-02-without-expect/output.txt}}
```

Rust предупреждает о не использовании значения `Result`, возвращаемого из `read_line`, показывая, что программа не учла возможность возникновения ошибки.

Правильный способ убрать предупреждение - это написать обработку ошибок, но в нашем случае мы просто хотим аварийно завершить программу при возникновении проблемы, поэтому используем `expect`. О способах восстановления после ошибок вы узнаете в [главе 9](ch09-02-recoverable-errors-with-result.html).

### Напечатать значений с помощью заполнителей `println!`

Кроме закрывающей фигурной скобки, в коде на данный момент есть еще только одна строка для обсуждения:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:print_guess}}
```

Эта строка печатает строку, которая теперь содержит ввод пользователя. Набор фигурных скобок `{}` является заполнителем: думайте о `{}` как о маленьких крабовых клешнях, удерживающих значение на месте. С помощью фигурных скобок можно вывести более одного значения: первый набор фигурных скобок содержит первое значение, указанное после форматирующей строки, второй набор - второе значение и так далее. Печать нескольких значений за один вызов `println!` будет выглядеть следующим образом:

```rust
let x = 5;
let y = 10;

println!("x = {} and y = {}", x, y);
```

Этот код напечатает `x = 5 and y = 10`.

### Тестирование первой части

Давайте протестирует первую часть игры. Запустите её используя `cargo run`:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```

На данном этапе первая часть игры завершена: мы получаем ввод с клавиатуры и затем печатаем его.

## Генерация секретного числа

Далее нам нужно сгенерировать секретное число, которое пользователь попытается угадать. Секретное число должно быть каждый раз разным, чтобы в игру можно было играть несколько раз. Мы будем использовать случайное число в диапазоне от 1 до 100, чтобы игра не была слишком сложной. Rust пока не включает функциональность случайных чисел в свою стандартную библиотеку. Однако команда Rust предоставляет [`rand` crate](https://crates.io/crates/rand) с подобной функциональностью.

### Использование пакета для получения дополнительной функциональности

Помните, что пакет (crate) - это коллекция файлов исходного кода Rust. Проект, создаваемый нами, представляет собой <br> *бинарный пакет (binary crate)*, который является исполняемым файлом. Пакет `rand` - это *библиотечный пакет (library crate)*, содержащий код, который предназначен для использования в других программах и поэтому не может исполняться сам по себе.

Координация работы внешних пакетов является тем местом, где Cargo действительно блистает. Чтобы начать писать код, использующий `rand`, необходимо изменить файл *Cargo.toml*, включив в него в качестве зависимости пакет `rand`. Итак, откройте этот файл и добавьте следующую строку внизу под заголовком секции `[dependencies]`, созданным для вас Cargo. Обязательно укажите `rand` в точности как здесь, с таким же номером версии, иначе примеры кода из этого урока могут не заработать.

<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->

<span class="filename">Имя файла: Cargo.toml</span>

```toml
{{#include ../listings/ch02-guessing-game-tutorial/listing-02-02/Cargo.toml:9:}}
```

В файле *Cargo.toml* все, что следует за заголовком, является частью этой секции, которая продолжается до тех пор, пока не начнется другая секция. В `[dependencies]` вы сообщаете Cargo, от каких внешних пакетов зависит ваш проект и какие версии этих пакетов вам нужны. В нашем случае мы указываем пакет `rand` с семантическим спецификатором версии `0.8.3`. Cargo понимает [Семантическое Версионирование (Semantic Versioning)](http://semver.org) (иногда называемое *SemVer*), которое является стандартом для написания номеров версий. Число `0.8.3` на самом деле является сокращением для `^0.8.3`, что означает любую версию, которая не ниже `0.8.3`, но не выше `0.9.0`. Cargo полагает, что эти версии имеют публичные API, совместимые с версией `0.8.3`, и эта спецификация гарантирует, что вы получите последний выпуск патча, который все еще будет компилироваться с кодом из этой главы. Любая версия `0.9.0` или выше не гарантирует наличие того же API, что используется в следующих примерах.

Теперь, не меняя ничего в коде, давайте соберем проект, как показано в листинге 2-2.

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo clean
cargo build -->

```console
$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
  Downloaded libc v0.2.86
  Downloaded getrandom v0.2.2
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.10
  Downloaded rand_chacha v0.3.0
  Downloaded rand_core v0.6.2
   Compiling rand_core v0.6.2
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
```

<span class="caption">Листинг 2-2: Результат выполнения <code>cargo build</code> после добавления пакета rand в качестве зависимости</span>

Вы можете увидеть другие номера версий (но все они будут совместимы с кодом, благодаря SemVer!), другие строки (в зависимости от операционной системы), а также строки могут быть расположены в другом порядке.

Когда мы включаем внешнюю зависимость, Cargo берет последние версии всего, что нужно этой зависимости, из *реестра (registry)*, который является копией данных с [Crates.io](https://crates.io/). Crates.io - это место, где участники экосистемы Rust размещают свои проекты Rust с открытым исходным кодом для использования другими.

После обновления реестра Cargo проверяет раздел `[dependencies]` и загружает все указанные в списке пакеты, которые еще не были загружены. В нашем случае, хотя мы указали только `rand` в качестве зависимости, Cargo также захватил другие пакеты, от которых зависит работа `rand`. После загрузки пакетов Rust компилирует их, а затем компилирует проект с имеющимися зависимостями.

Если сразу же запустить `cargo build` снова, не внося никаких изменений, то кроме строки `Finished` вы не получите никакого вывода. Cargo знает, что он уже загрузил и скомпилировал зависимости, и вы не вносили никаких изменений в файл *Cargo.toml*. Cargo также знает, что вы ничего не изменили в своем коде, поэтому он не перекомпилирует и его. Если делать нечего, он просто завершает работу.

Если открыть файл *src/main.rs*, внести незначительные изменения, а затем сохранить его и снова произвести сборку, то вы увидите только две строки вывода:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->

```console
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
```

Эти строки показывают, что Cargo обновляет сборку только на основании вашего крошечного изменения в файле *src/main.rs*. Поскольку зависимости не изменились, Cargo знает, что может повторно использовать ранее загруженные и скомпилированные зависимости.

#### Обеспечение воспроизводимых сборок с помощью файла *Cargo.lock*

В Cargo есть механизм, обеспечивающий возможность пересобрать все тот же артефакт каждый раз, когда вы или кто-либо другой собирает ваш код. Пока вы не укажете обратное, Cargo будет использовать только те версии зависимостей, которые были заданы ранее. Например, допустим, что на следующей неделе выходит версия 0.8.4 пакета `rand` , и эта версия содержит важное исправление ошибки, но также содержит регрессию, которая может сломать ваш код. Чтобы справиться с этим, Rust создает файл *Cargo.lock* при первом запуске `cargo build`, поэтому теперь он есть в каталоге *guessing_game*.

Когда вы собираете проект в первый раз, Cargo определяет все версии зависимостей, удовлетворяющие критериям, а затем записывает их в файл *Cargo.lock*. Когда вы будете собирать свой проект в будущем, Cargo увидит, что файл *Cargo.lock* уже существует, и будет использовать указанные в нем версии вместо повторения работы по определению версий. Это дает возможность автоматически получить воспроизводимую сборку. Другими словами, благодаря файлу *Cargo.lock* ваш проект останется на версии `0.8.3`, пока вы явно не обновитесь.

#### Обновление пакета для получения новой версии

Если вы *захотите* обновить пакет, Cargo предоставляет команду `update`, которая игнорирует файл *Cargo.lock* и определяет последние версии, соответствующие вашим спецификациям из файла *Cargo.toml*. После этого Cargo запишет эти версии в файл *Cargo.lock*. Иначе, по умолчанию, Cargo будет искать только версии больше `0.8.3` , но при этом меньше `0.9.0`. Если пакет `rand` имеет две новые версии `0.8.4` и `0.9.0`, то при запуске `cargo update` вы увидите следующее:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->

```console
$ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -> v0.8.4
```

Cargo игнорирует релиз `0.9.0`. В этот момент также появится изменение в файле *Cargo.lock*, указывающее на то, что версия `rand`, которая теперь используется, равна `0.8.4`. Чтобы использовать `rand` версии `0.9.0` или любой другой версии из серии `0.9.x`, необходимо обновить файл *Cargo.toml* следующим образом:

```toml
[dependencies]
rand = "0.9.0"
```

В следующий раз, при запуске `cargo build`, Cargo обновит реестр доступных пакетов и пересмотрит ваши требования к `rand` в соответствии с новой версией, которую вы указали.

Много еще можно рассказать о [Cargo](http://doc.crates.io) и [его экосистеме](http://doc.crates.io/crates-io.html), о которой мы поговорим в главе 14, но сейчас это все, что следует знать. Cargo упрощает повторное использование библиотек, поэтому Rustaceans могут писать небольшие проекты, собранные из нескольких пакетов (packages).

### Генерация случайного числа

Давайте начнем использовать `rand` чтобы сгенерировать число для угадывания. Следующим шагом будет обновление *src/main.rs*, как показано в Листинге 2-3.

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-03/src/main.rs:all}}
```

<span class="caption">Листинг 2-3: Добавление кода для генерации случайного числа</span>

Сначала мы добавляем строку `use rand::Rng`. Типаж `Rng` определяет методы, реализующие генераторы случайных чисел, и этот типаж должен быть в области видимости, чтобы можно было использовать эти методы. В главе 10 мы подробно рассмотрим типажи.

Далее мы добавляем две строки посередине. В первой строке вызов функции `rand::thread_rng`, предоставляющей нам специальный генератор случайных чисел, который мы собираемся использовать: локальный для текущего потока выполнения и заполняемый операционной системой. Затем вызываем метод `gen_range` на генераторе случайных чисел. Этот метод определяется типажом `Rng`, который мы ввели в область видимости с помощью оператора `use rand::Rng`. Метод `gen_range` принимает выражение диапазона в качестве аргумента и генерирует случайное число в пределах диапазона. Выражение диапазона, которое здесь используется, имеет форму `start...end` и является инклюзивным по нижней границе, но эксклюзивным по верхней, поэтому нужно указать `1...101`, чтобы запросить число от 1 до 100. Как вариант, можно передать диапазон `1..=100`, что будет эквивалентно.

> Примечание: Не просто сразу разобраться, какие типажи использовать, какие методы и функции вызывать из пакета, поэтому каждый пакет имеет документацию с инструкциями по его использованию. Еще одной замечательной особенностью Cargo является выполнение команды `cargo doc --open`, которая локально собирает документацию, предоставляемую всеми вашими зависимостями, и открывает ее в браузере. К примеру, если интересна другая функциональность из пакета `rand`, запустите `cargo doc --open` и нажмите `rand` в боковой панели слева.

Во второй новой строке печатается секретный номер. Полезно, пока разрабатывается программа, иметь возможность тестировать ее, но в финальной версии мы это удалим. Конечно это не похоже на игру, если программа печатает ответ сразу после запуска!

Попробуйте запустить программу несколько раз:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
```

Вы должны получить разные случайные числа, и все они должны быть числами в диапазоне от 1 до 100. Отличная работа!

## Сравнение догадки с секретным числом

Теперь, когда у нас есть пользовательский ввод и случайное число, мы можем сравнить их. Этот шаг показан в листинге 2-4. Учтите, что этот код еще не скомпилируется, подробнее мы объясним дальше.

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-04/src/main.rs:here}}
```

<span class="caption">Листинг 2-4: Обработка возможных возвращаемых значений при сравнении двух чисел</span>

Сначала добавим еще один оператор `use`, который вводит тип с именем `std::cmp::Ordering` в область видимости из стандартной библиотеки. Тип `Ordering` является еще одним перечислением и имеет варианты `Less`, `Greater` и `Equal`. Это три возможных исхода, при сравнении двух величин.

После чего ниже добавляем пять новых строк, использующих тип `Ordering`. Метод `cmp` сравнивает два значения и может вызываться для всего, что можно сравнить. Он принимает ссылку на все, что требуется сравнить: здесь сравнивается `guess` с `secret_number`. В результате возвращается вариант перечисления `Ordering`, которое мы ввели в область видимости с помощью оператора `use`. Для принятия решения о том, что делать дальше, мы используем выражение [`match`](ch06-02-match.html), определяющее, какой вариант `Ordering` был возвращен из вызова `cmp` со значениями `guess` и `secret_number`.

Выражение `match` состоит из *веток (arms)*. Ветка состоит из *шаблона* для сопоставления и кода, который будет запущен, если значение, переданное в `match`, соответствует шаблону этой ветки. Rust принимает значение, заданное `match`, и по очереди просматривает шаблон каждой ветки. Шаблоны и конструкция `match` - это мощные возможности Rust, позволяющие выразить множество ситуаций, с которыми может столкнуться ваш код, и гарантировать их обработку. Эти возможности будут подробно раскрыты в Главе 6 и Главе 18 соответственно.

Давайте рассмотрим пример с выражением `match`, который используется здесь. Допустим, пользователь предположил число 50, а случайно сгенерированное секретное число в этот раз равно 38. Когда код сравнит 50 с 38, метод `cmp` вернет `Ordering::Greater`, потому что 50 больше 38. Выражение `match` получит значение `Ordering::Greater` и начнет проверку шаблона каждой ветки. Сначала он посмотрит на шаблон первой ветки, `Ordering::Less`, но увидит, что значение `Ordering::Greater` не сопоставляется с `Ordering::Less`, поэтому код в этой ветке будет проигнорирован, и перейдет к следующей ветке. Шаблон следующей ветки - `Ordering::Greater`, который успешно *сопоставляется* с `Ordering::Greater`! Связанный код из этой ветки будет выполнен и распечатает `Too big!` на экране. Так как теперь не требуется рассматривать последнюю ветку в этом сценарии, выражение `match` прекратит выполнение.

Однако, код в листинге 2-4 все ещё не скомпилируется. Давайте попробуем:

```console
{{#include ../listings/ch02-guessing-game-tutorial/listing-02-04/output.txt}}
```

Суть ошибки заключается в наличии *несовпадающих типов*. У Rust строгая, статическая система типов. Однако он также имеет вывод типов. Когда мы написали `let mut guess = String::new()`, Rust смог сделать вывод, что `guess` должна быть `String` и не заставил указывать тип. С другой стороны, `secret_number` - это числовой тип. Несколько типов чисел в Rust могут иметь значение от 1 до 100: `i32`, 32-битное число; `u32`, беззнаковое 32-битное число; `i64`, 64-битное число, а также другие. Если не указано иное, Rust по умолчанию использует `i32`, который будет типом `secret_number`, если не добавлять информацию о типе в другом месте, которая заставит Rust вывести другой числовой тип. Причина ошибки заключается в том, что Rust не может сравнить строку и числовой тип.

В конечном итоге, необходимо преобразовать `String`, считываемую программой в качестве входных данных, в реальный числовой тип, чтобы иметь возможность числового сравнения с секретным числом. Для этого добавьте эту строку в тело функции `main`:

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/src/main.rs:here}}
```

Вот эта строка:

```rust,ignore
let guess: u32 = guess.trim().parse().expect("Please type a number!");
```

Мы создаем переменную с именем `guess`. Но подождите, разве в программе уже нет переменной с этим именем `guess`? Так и есть, но Rust позволяет нам *затенять* предыдущее значение `guess` новым. Затенение позволяет нам повторно использовать имя переменной `guess`, чтобы избежать создания двух уникальных переменных, таких как `guess_str` и `guess`, например. Мы рассмотрим это более подробно в главе 3, а пока знайте, что эта функция часто используется, когда необходимо преобразовать значение из одного типа в другой.

Мы связываем эту новую переменную с выражением `guess.trim().parse()`. Переменная `guess` в этом выражении относится к исходной переменной `guess`, которая содержала входные данные в виде строки. Метод `trim` на экземпляре `String` удалит любые пробельные символы в начале и конце строки для того, чтобы мы могли сопоставить строку с `u32`, которая содержит только числовые данные. Пользователь должен нажать <span class="keystroke">enter</span>, чтобы выполнить `read_line` и ввести свою догадку, при этом в строку добавится символ новой строки. Например, если пользователь набирает <span class="keystroke">5</span> и нажимает <span class="keystroke">enter</span>, `guess` будет выглядеть так: `5\n`. Символ `\n` означает "новая строка". (В Windows нажатие <span class="keystroke">enter</span> сопровождается возвратом каретки и новой строкой, `\r\n`). Метод `trim` убирает `\n` или `\r\n`, оставляя только `5`.

[Метод строк `parse`](../std/primitive.str.html#method.parse) преобразует строку в некоторое число. Поскольку этот метод может преобразовывать различные числовые типы, мы должны сообщить Rust конкретный числовой тип, который нам нужен, используя `let guess: u32`. Двоеточие (`:`) после `guess` сообщает Rust, что мы будем аннотировать тип переменной. В Rust есть несколько встроенных числовых типов. Представленный здесь тип `u32` - это беззнаковое 32-битное целое число. Это хороший выбор по умолчанию для небольшого положительного числа. О других числовых типах вы узнаете в Главе 3. Кроме того, аннотация `u32` в этом примере программы и сравнение с `secret_number` позволяет Rust сделать вывод, что `secret_number` также должен быть <code>u32</code>. Таким образом, теперь сравнение будет проводиться между двумя значениями одного типа!

Метод `parse` будет работать только с символами, которые логически могут быть преобразованы в числа, и поэтому легко может вызвать ошибки. Если, например, строка содержит `A👍%`, преобразовать её в число невозможно. Так как метод `parse` может потерпеть неудачу, возвращается тип `Result`, так же как и метод `read_line` (обсуждалось ранее в разделе <a href="#handling-potential-failure-with-the-result-type" data-md-type="link">"Обработка потенциальной неудачи с помощью `Result` Type"</a>). Мы будем точно так же обрабатывать данный `Result`, вновь используя метод `expect`. Если `parse` вернет вариант `Result` `Err`, так как не смог создать число из строки, вызов `expect` аварийно завершит игру и распечатает переданное ему сообщение. Если `parse` сможет успешно сконвертировать строку в число, он вернет вариант `Result` `Ok`, а `expect` вернет число, полученное из значения `Ok`.

Давайте запустим программу теперь!

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
cargo run
  76
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
```

Хорошо! Несмотря на то, что были добавлены пробелы перед догадкой 76, программа все равно вывела пользовательскую догадку 76. Запустите программу несколько раз, чтобы проверить разное поведение при различных типах ввода: задайте число правильно, задайте слишком большое число и задайте слишком маленькое число.

Сейчас у нас работает большая часть игры, но пользователь может сделать только одну догадку. Давайте изменим это, добавив цикл!

## Возможность нескольких догадок с помощью циклов

Ключевое слово `loop` создает бесконечный цикл. Мы добавляем цикл, чтобы дать пользователям больше шансов угадать число:

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-04-looping/src/main.rs:here}}
```

Как видите, мы переместили все, начиная с подсказки ввода догадки, в цикл. Не забудьте добавить еще по четыре пробела на отступы строк внутри цикла и запустите программу снова. Теперь программа будет бесконечно запрашивать еще одну догадку, что фактически создает новую проблему. Похоже пользователь не сможет выйти из игры!

Пользователь может прервать выполнение программы с помощью сочетания клавиш <span class="keystroke">ctrl-c</span>. Но есть и другой способ спастись от этого ненасытного монстра, о котором говорилось при обсуждении `parse` в ["Сравнение догадки с секретным числом"](#comparing-the-guess-to-the-secret-number): если пользователь введет нечисловой ответ, программа завершится аварийно. Мы можем воспользоваться этим, чтобы позволить пользователю выйти из игры, как показано здесь:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

Ввод `quit` приведет к выходу из игры, но, как вы заметите, так же будет и при любом другом нечисловом вводе. Однако это, мягко говоря, не оптимально. Мы хотим, чтобы игра автоматически остановилась, когда будет угадано правильное число.

### Выход после правильной догадки

Давайте запрограммируем игру на выход при выигрыше пользователя, добавив оператор `break`:

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-05-quitting/src/main.rs:here}}
```

Добавление строки `break` после `You win!` заставляет программу выйти из цикла, когда пользователь правильно угадает секретное число. Выход из цикла также означает выход из программы, так как цикл является последней частью `main`.

### Обработка недопустимого ввода

Чтобы еще улучшить поведение игры, вместо аварийного завершения программы, когда пользователь вводит не число, давайте заставим игру проигрывать этот случай, позволяя пользователю продолжить угадывание. Для этого необходимо изменить строку, в которой `guess` преобразуется из `String` в `u32`, как показано в Листинге 2-5.

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-05/src/main.rs:here}}
```

<span class="caption">Листинг 2-5. Игнорирование нечисловой догадки и запрос другой догадки вместо завершения программы</span>

Мы переключаем вызов `expect` на выражение `match`, чтобы перейти от аварийного завершения при ошибке к обработке ошибки. Помните, что `parse` возвращает тип `Result`, а `Result` - это перечисление, которое имеет варианты `Ok` и `Err`. Здесь мы используем выражение `match`, как и в случае с результатом `Ordering` метода `cmp`.

Если `parse` успешно преобразует строку в число, он вернет значение `Ok`, содержащее полученное число. Это значение `Ok` будет соответствовать шаблону первой ветки, а выражение `match` просто вернет значение `num`, которое `parse` произвел и поместил внутрь значения `Ok`. Это число окажется в нужной нам переменной `guess`, которую мы создали.

Если метод `parse` *не способен* превратить строку в число, он вернёт значение `Err`, которое содержит более подробную информацию об ошибке. Значение `Err` не совпадает с шаблоном `Ok(num)` в первой ветке `match`, но совпадает с шаблоном `Err(_)` второй ветки. Подчёркивание `_` является всеохватывающим выражением. В этой ветке мы говорим, что хотим обработать совпадение всех значений `Err`, независимо от того, какая информация находится внутри `Err`. Поэтому программа выполнит код второй ветки, `continue`, который сообщает программе перейти к следующей итерации <code>loop</code> и запросить еще одну догадку. В этом случае программа эффективно игнорирует все ошибки, с которыми может столкнуться <code>parse</code>!

Все в программе теперь должно работать как положено. Давайте попробуем:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 4.45s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
```

Потрясающе! С помощью одной маленькой последней правки мы закончим игру в угадайку. Напомним, что программа все еще печатает секретное число. Это хорошо подходило для тестирования, но это портит игру. Давайте удалим `println!`, который выводит секретное число. В Листинге 2-6 показан окончательный вариант кода.

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-06/src/main.rs}}
```

<span class="caption">Листинг 2-6: Полный код игры угадайки</span>

## Итоги

На данный момент вы успешно создали игру угадайку. Поздравляем!

Этот проект - практический способ познакомить вас со многими новыми концепциями Rust: `let`, `match`, функции, использование внешних пакетов и многое другое. В следующих нескольких главах вы изучите эти концепции более подробно. Глава 3 охватывает понятия, которые есть в большинстве языков программирования, такие как переменные, типы данных и функции, и показывает, как использовать их в Rust. В главе 4 рассматривается владение, особенность, которая отличает Rust от других языков. В главе 5 обсуждаются структуры и синтаксис методов, а в главе 6 объясняется, как работают перечисления.
