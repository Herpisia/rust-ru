## Векторы

Первым типом коллекции, который мы разберём будет *вектор* `Vec<T>`. Векторы позволяют сохранять множество данных в одной структуре, сохраняя элементы в памяти один за другим. Векторы могут сохранять данные только одного типа. Они удобны, когда нужно иметь список элементов, такие как текстовые строки в файле или цены в списке корзины покупок.

### Создание нового вектора

Для создания нового вектора используется функция `Vec::new`, как показано в листинге 8-1.

```rust
let v: Vec<i32> = Vec::new();
```

<span class="caption">Листинг 8-1. Создание нового пустого вектора для хранения значений
типа <code>i32</code></span>

Обратите внимание, что здесь мы добавили аннотацию типа данных. Пока мы не добавляем хотя бы один элемент в вектор, компилятор Rust не знает элементы какого типа мы собираемся хранить в коллекции. Это важный момент. Вектор реализован с помощью обобщённых типов;  в главе 10 мы поговорим как использовать обобщённые типы вашими собственными типами. Сейчас достаточно знать, что тип `Vec<T>` предоставленный стандартной библиотекой может хранить любой тип, и конкретный вектор хранит определённый тип указанный в угловых скобках. В листинге 8-1, мы указали Rust что тип `Vec<T>` в переменной `v` будет содержать элементы типа `i32`.

В более реалистичном коде Rust часто может выводить тип значения, которое вы собираетесь хранить, как только вы вставляете значения, поэтому делать такую аннотацию типа приходится редко. Чаще встречается создание `Vec<T>` с начальными значениями и Rust для удобства предоставляет макрос `vec!`. Макрос создаёт новый вектор содержащий значения, которые вы ему укажете. Листинг 8-2 создаёт новый `Vec<i32>`, который содержит значения `1`, `2` и `3`.

```rust
let v = vec![1, 2, 3];
```

<span class="caption">Листинг 8-2. Создание нового вектора, содержащего значения</span>

Поскольку мы указали начальные значения `i32`, Rust может сделать вывод, что тип переменной `v` это `Vec<i32>`  и аннотация типа здесь не нужна. Далее мы посмотрим как изменять вектор.

### Изменение вектора

Чтобы создать вектор и затем добавить к нему элементы, можно использовать метод `push` показанный в листинге 8-3.

```rust
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
```

<span class="caption">Листинг 8-3. Использование метода <code>push</code> для добавления значений в вектор</span>

Как и с любой переменной, если мы хотим изменить её значение, нам нужно сделайте её изменяемой с помощью ключевого слова `mut`, как мы обсудили в главе 3. Числа мы помещаем в вектор типа `i32` и Rust выводит это из данных, так что аннотация `Vec<i32>`  здесь не нужна.

### Удаление элементов из вектора

Подобно любой другой структуре `struct`, вектор освобождается, когда он выходит из области видимости, как прокомментировано в листинге 8-4.

```rust
{
    let v = vec![1, 2, 3, 4];

    // использование вектора v

} // <- v уходит из области видимости и здесь память освобождена
```

<span class="caption">Листинг 8-4. Показывает где вектор и его элементы удалены</span>

Когда вектор удаляется, все его содержимое также удаляется, что означает и удаление чисел, которые он содержит. Это может показаться простой концепцией, но все становится немного сложнее, когда вы начинаете вводить ссылки на элементы вектора. Давайте займёмся этим далее!

### Чтение данных вектора

Теперь, когда вы знаете, как создавать, обновлять и уничтожать вектор, знание про чтение его содержимого является следующим шагом. Есть два способа ссылаться на значение хранящееся в векторе. В примерах мы аннотировали типы значений возвращаемых из функций для большей ясности.

Листинг 8-5 показывает два метода доступа к значению в векторе, индексным синтаксисом или методом `get`.

```rust
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
println!("The third element is {}", third);

match v.get(2) {
    Some(third) => println!("The third element is {}", third),
    None => println!("There is no third element."),
}
```

<span class="caption">Листинг 8-5. Использование индексного синтаксиса или метода <code>get</code> для получения доступа к элементу вектора</span>

Обратите внимание здесь на пару деталей. Во-первых, используется значение индекса `2` для получения третьего элемента: векторы индексируются по номеру начиная с нуля. Во-вторых, два способа получения третьего элемента используя `&` и `[]` возвращающих ссылку или с помощью метода `get` с индексом, переданным в качестве аргумента, который возвращает `Option<&T>`.

У Rust есть два способа сослаться на элемент, так что вы можете выбрать, как программа ведёт себя при попытке использовать значение индекса, для которого в векторе нет элемента. В качестве примера, давайте посмотрим что будет делать программа если у неё есть вектор, который содержит пять элементов, а мы пытаемся получить доступ к элементу с индексом 100, как показано в листинге 8-6.

```rust,should_panic,panics
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
```

<span class="caption">Листинг 8-6. Попытка доступа к элементу вектора по индексу 100, содержащему всего пять элементов</span>

Когда мы запустим этот код, первый метод `[]` вызовет в программе панику, потому что он ссылается на несуществующий элемент. Этот метод лучше всего использовать, когда вы хотите, чтобы ваша программа аварийно завершала работу при попытке доступа к элементу за пределами вектора.

Когда методу `get` передаётся индекс, находящийся за пределами вектора, он возвращает значение `None` без возникновения паники. Вы можете использовать этот метод при доступе к элементу выходящему за пределы диапазона вектора в нормальных условиях. Тогда код будет иметь логику для обработки наличия или значения `Some(&element)` или `None`, как обсуждалось в главе 6. Например, индекс мог бы быть получен от человека, вводящего номер вручную. Если он случайно введёт слишком большой номер и программа получает значение `None`, то вы можете сказать пользователю, сколько элементов находится в текущем векторе и дать ему ещё один шанс ввести существующий номер. Это было бы более удобным для пользователя, чем сбой программы из-за опечатки!

Когда в программе есть действительная ссылка, средство проверки заимствований обеспечивает выполнение правил владения и заимствования (описанные в главе 4), чтобы обеспечить этой ссылке и любым другим ссылкам на содержимое вектора, остаться действительными. Напомним, правило гласит, что вы не можете иметь изменяемые и неизменные ссылки в одной области видимости. Это правило применяется в листинге 8-7, где мы имеем неизменяемую ссылку на первый элемент вектора и пытаемся добавить некоторый элемент в его конец. Код не будет работать.

```rust,ignore,does_not_compile
let mut v = vec![1, 2, 3, 4, 5];

let first = &v[0];

v.push(6);

println!("The first element is: {}", first);
```

<span class="caption">Листинг 8-7. Попытка добавить некоторый элемент в вектор, удерживая неизменяемую ссылку на элемент</span>

Компиляция этого кода приведёт к ошибке:

```text
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --> src/main.rs:6:5
  |
4 |     let first = &v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("The first element is: {}", first);
  |                                          ----- immutable borrow later used here
```

Код листинга 8-7 может выглядеть так, как будто он должен бы работать: почему ссылка на первый элемент должна волноваться о том, что меняется в конце вектора? Это ошибка связана с тем, как работают векторы: добавление нового элемента в конец вектора может потребовать выделения нового блока памяти и копирования старых элементов в новое пространство, если будет недостаточно места для размещения всех  элементов рядом друг с другом там, где вектор находится в данное время. В этом случае ссылка на первый элемент будет указывать на освобождённую память. Правила заимствования предотвращают возможность программе оказаться в такой ситуации.

> Примечание. Дополнительные сведения о реализации типа `Vec<T>` см. в разделе «The
> Rustonomicon » по адресу https://doc.rust-lang.org/stable/nomicon/vec.html.

### Перебор значений в векторе

Если нужно получить доступ к каждому элементу вектора по очереди, можно перебирать все элементы, а не использовать индексы для доступа по одному в один момент времени. В листинге 8-8 показано, как использовать цикл `for` для получения неизменяемых ссылок на каждый элемент вектора со значениями типа `i32` и распечатывания их.

```rust
let v = vec![100, 32, 57];
for i in &v {
    println!("{}", i);
}
```

<span class="caption">Листинг 8-8. Печать каждого элемента в векторе, перебирая элементы с помощью цикла <code>for</code></span>

Мы также можем перебирать изменяемые ссылки на каждый элемент изменяемого вектора для того, чтобы внести изменения во все элементы. Цикл `for` в листинге 8-9 добавит число `50` к каждому элементу.

```rust
let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;
}
```

<span class="caption">Листинг 8-9. Итерация по изменяемым ссылкам на элементы вектора</span>

Чтобы изменить значение на которое ссылается изменяемая ссылка, мы должны использовать оператор разыменования (`*`) для получения значение в переменную `i` прежде чем использовать оператор `+=`. Мы поговорим подробнее об операторе разыменования в разделе [«Следуя указателю на значение с помощью оператора разыменования»](ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator) главы 15.

### Использование перечисления для хранения множества разных типов

В начале этой главы мы говорили, что векторы могут хранить только значения одинакового типа. Это может быть неудобно; безусловно есть случаи, когда необходим список из элементов разного типа. К счастью, варианты перечисления определены в самом типе перечисления, поэтому когда нам нужно хранить в векторе элементы различного типа, можно определить и использовать перечисление!

Например, мы хотим получить значения из строки в электронной таблице где некоторые столбцы строки содержат целые числа, некоторые числа с плавающей точкой или строковые значения. Можно определить перечисление, варианты которого будут содержать разные типы значений и тогда все варианты перечисления будут считаться одними и тем же типом: самим перечислением. Затем можно создать вектор, который содержит это перечисление и таким образом в конечном счёте содержит разные типы. Мы продемонстрировали это в листинге 8-10.

```rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
```

<span class="caption">Листинг 8-10. Определение <code>enum</code> для хранения значений разных типов в векторе</span>

Rust должен знать, какие типы будут в векторе во время компиляции, чтобы знать сколько именно памяти в куче потребуется для хранения каждого элемента. Вторичным преимуществом является то, что мы можем чётко указать какие типы разрешены в таком векторе. Если бы Rust позволял вектору содержать любой тип, был бы шанс что один или несколько типов будут вызывать ошибки при выполнении операций над элементами вектора. Используя перечисление вместе с выражением `match` означает, что во время компиляции Rust гарантирует  обработку каждого возможного случая, как обсуждалось в главе 6.

При написании программы, если вы не знаете исчерпывающий набор типов программы во время выполнения для сохранения их в вектор,  то техника использования перечисления не будет работать. Вместо этого вы можете использовать объект типажа, который мы рассмотрим в главе 17.

Теперь, когда мы обсудили некоторые из наиболее распространённых способов использования векторов, просмотрите документацию по API для всего множества полезных методов, определённых в `Vec<T>` из стандартной библиотеки. Например, в дополнение к методам `push`, `pop` есть метод удаления и возвращения последнего элемента. Давайте перейдём к следующему типу коллекций: строки `String`!
