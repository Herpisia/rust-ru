# Многопоточность без страха

Безопасное и качественное управление многопоточным программированием — ещё одна из основных целей Ржавчина*Многопоточное программирование*, когда разные части программы выполняются независимо, и *одновременное программирование*, когда разные части программы выполняются одновременно, становятся всё более важными, поскольку всё больше компьютеров используют преимущества нескольких процессоров. Так сложилось, что программирование в этих условиях было сложным и подверженным ошибкам: Ржавчина надеется изменить это.

Первоначально объединение разработчиков Ржавчины считало, что обеспечение безопасности памяти и предотвращение неполадок многопоточности — это два отдельных сбоя, которые необходимо решать различными способами. Со временем объединение разработчиков обнаружило, что системы владения и перечень видов данных являются мощным набором средств, помогающих управлять безопасностью памяти *и* неполадками многопоточной одновременности! Используя владение и проверку видов данных, многие ошибки многопоточности являются ошибками времени сборки в Ржавчине, а не ошибками времени выполнения. Поэтому вместо того, чтобы тратить много времени на попытки воспроизвести точные обстоятельства, при которых возникает ошибка многопоточности во время выполнения, неправильная рукопись будет отклонена с ошибкой. В итоге вы можете исправить свою рукопись во время работы над ней, а не после развёртывания на рабочем отдельном вычислителе. Мы назвали эту особенность Ржавчины *бесстрашной* *многопоточностью*. Бесстрашная многопоточность позволяет вам писать рукопись, которая не содержит скрытых ошибок и легко повторно согласуется без внесения новых.

> Примечание: для простоты мы будем называть многие сбои *многопоточными*, хотя более точное понятие здесь *&nbsp;— многопоточные и/или одновременные*. Если бы эта книга была о многопоточности и/или одновременности, мы были бы более определены. В этой главе, пожалуйста, всякий раз, когда мы используем понятие *«многопоточный»*, мысленно замените на понятие *«многопоточный и/или одновременный»*.

Многие языки предлагают довольно устоявшиеся решения неполадок многопоточности. Например, Erlang обладает элегантной возможностью для многопоточности при передаче сообщений, но не определяет ясных способов совместного использования состояния между потоками. Поддержка только подмножества возможных решений является разумной подходом для языков более высокого уровня, поскольку язык более высокого уровня обещает выгоду при отказе от некоторого управления над получением абстракций. Однако ожидается, что языки низкого уровня обеспечат решение с наилучшей производительностью в любом  случае и будут иметь меньше абстракций по сравнению с аппаратным обеспечением. Поэтому Ржавчина предлагает множество средств для расчетов неполадок любым способом, который подходит для вашего случая и требований.

Вот сути, которые мы рассмотрим в этой главе:

- Как создать потоки для одновременного запуска нескольких отрывков рукописи
- Многопоточность *передачи сообщений*, где потоки передают сообщения между потоками
- Многопоточность для *совместно используемого состояния*, когда несколько потоков имеют доступ к некоторому отрывку данных
- Сущности `Sync` и `Send`, которые расширяют заверения многопоточности в Ржавчине для пользовательских видов данных, а также видов данных, предоставляемых встроенной библиотекой
