## `panic!` или не `panic!`

Итак, как принимается решение о том, когда следует вызывать `panic!` и когда вернуть `Result` ? При панике код не имеет возможности восстановить своё выполнение. Можно было бы вызывать `panic!` для любой ошибочной ситуации, имеется ли возможный способ восстановления или его нет, но с другой стороны вы принимаете решение от имени кода, вызывающего ваш код о том, что ситуация необратима. Если вы решаете вернуть значение `Result`, вы даёте вызывающему коду варианты, а не принимаете решение за него. Вызывающий код может выбрать попытку восстановления способом, который подходит для его ситуации или он может решить, что значение `Err` в этом случае нельзя восстановить, поэтому он может вызвать `panic!` и превратить вашу исправимую ошибку в неисправимую. Поэтому возвращение `Result` является хорошим выбором по умолчанию при объявлении функции, которая может дать сбой.

В редких случаях более уместно писать код, который паникует вместо возвращения `Result`. Давайте рассмотрим, почему уместно паниковать на примерах, в коде прототипа и тестах. Затем мы обсудим ситуации, в которых компилятор не может сказать, что неудачный вызов невозможен, но вы, как человек, можете это сказать. Глава будет заканчиваться некоторыми общими руководящими принципами о том, как решить, стоит ли паниковать в коде библиотеки.

### Примеры, код прототипа и тесты

Когда вы пишете пример, иллюстрирующий некоторую концепцию, наличие хорошего кода обработки ошибок может сделать пример менее понятным. В примерах понятно, что вызов метода `unwrap` может вызвать панику, что означает наличие такого места в приложении, где будут обрабатываться ошибки, которые могут отличаться в зависимости от того, что делает остальная часть вашего кода.

Точно так же методы `unwrap` и `expect` являются очень удобными при создании прототипа, прежде чем вы будете готовы решить, как обрабатывать ошибки. Они оставляют чёткие маркеры в коде до момента, когда вы будете готовы сделать программу более надёжной.

Если в тесте происходит сбой при вызове метода то, вы бы хотели чтобы весь тест не прошёл, даже если этот метод не является тестируемой функциональностью. Потому что вызов `panic!` это то, как тест помечается сбойным, вызов `unwrap` или `expect` именно то, что должно быть.

### Случаи, в которых у вас больше информации, чем у компилятора

Также было бы целесообразно вызывать `unwrap` когда у вас есть какая-то другая логика, которая гарантирует, что `Result` будет иметь значение `Ok`, но вашу логику не понимает компилятор. У вас по-прежнему будет значение `Result` которое нужно обработать: любая операция, которую вы вызываете, все ещё имеет возможность неудачи в целом, хотя это логически невозможно в вашей конкретной ситуации. Если проверяя код вручную вы можете убедиться, что никогда не будет вариант с `Err`, то вполне допустимо вызывать `unwrap`. Вот пример:

```rust
use std::net::IpAddr;

let home: IpAddr = "127.0.0.1".parse().unwrap();
```

Мы создаём экземпляр `IpAddr`, анализируя жёстко закодированную строку. Можно увидеть, что `127.0.0.1` является действительным IP-адресом, поэтому здесь допустимо использование `unwrap`. Однако наличие жёстко закодированной допустимой строки не меняет тип возвращаемого значения метода `parse`: мы все ещё получаем значение `Result` и компилятор все также заставляет нас обращаться с `Result` как будто возможен вариант `Err`, это потому что компилятор не достаточно умён, чтобы увидеть, что эта строка всегда действительный IP-адрес. Если строка IP-адреса пришла от пользователя, не является жёстко запрограммированной в программе и следовательно *имеет* возможность сбоя, мы определённо хотели бы обработать `Result` более надёжным способом.

### Руководство по обработке ошибок

Желательно, чтобы код паниковал, когда возможно что ваш код может оказаться в не корректном состоянии. В этом контексте *не корректное состояние* это тогда, когда некоторые допущение, гарантия, контракт или инвариант были нарушены, например, когда недопустимые значения, противоречивые значения или пропущенные значения передаются в ваш код - плюс один или несколько пунктов из следующего перечисленного в списке:

- Не корректное состояние это не то, что *ожидается* и будет иногда случаться
- Ваш код после этой точки должен полагаться на то, что он не находится в этом не корректном состоянии.
- Нет хорошего способа закодировать эту информацию в используемых вами типах.

Если кто-то вызывает ваш код и передаёт значения, которые не имеют смысла, лучшим выбор может быть вызов `panic!` для оповещения пользователя библиотеки, что есть ошибка в их коде для её исправления во время разработки. Точно так же, `panic!` является часто уместным, если вы вызываете внешний код, который находится вне вашего контроля и он возвращает недопустимое состояние, которое вы не можете исправить.

Тем не менее, когда ожидается сбой, более целесообразно вернуть `Result`, чем выполнить вызов `panic!`.  Примеры включают синтаксический анализатор, которому передали неправильно сформированные данные или HTTP-запрос, возвращающий статус указывающий на то, что вы достигли предела. В этих случаях возврат `Result` означает, что сбой является ожидаемой вероятностью того, что вызывающий код должен решить, как её обрабатывать.

Когда код выполняет операции над значениями, ваш код должен проверить в первую очередь то, что значения действительны и паниковать, если они не действительны. Это в основном из соображений безопасности: попытка оперировать с недействительными данными может подвергнуть ваш код уязвимости. Это основная причина, по которой стандартная библиотека будет вызывать `panic!` , если попытаться получить доступ к памяти за пределами: память не относящейся к текущей структуре данных является общей проблемой безопасности. Функции часто имеют *контракты* : их поведение гарантируется, только если входные данные отвечают определённым требованиям. Паника при нарушении контракта имеет смысл, потому что это всегда указывает на дефект со стороны вызывающего кода и это не ошибка, которую вы хотели бы чтобы вызывающий код должен был бы явно обработать. На самом деле, нет разумного способа для восстановления вызванного кода; *программисты* вызывающие ваш код должны исправить свой код. Контракты функции, особенно когда нарушение вызывает панику, следует объяснить в документации API функции.

Тем не менее, наличие множества проверок ошибок во всех ваших функциях было бы многословным и раздражительным. К счастью, можно использовать систему типов Rust (следовательно и проверку типов компилятором), чтобы сделать множество проверок вместо вас. Если ваша функция имеет определённый тип в качестве параметра, вы можете продолжить работу с логикой кода зная, что компилятор уже обеспечил правильное значение. Например, если используется обычный тип, а не тип `Option`, то ваша программа ожидает наличие *чего-то* вместо *ничего*. Ваш код не должен будет обрабатывать оба варианта `Some` и `None`: он будет иметь только один вариант для наличия определённого значения. Код, пытающийся ничего не передавать в функцию не будет даже компилироваться, поэтому ваша функция не должна проверять такой случай во время выполнения. Другой пример это использование целого типа без знака, такого как `u32`, который гарантирует, что параметр никогда не будет отрицательным.

### Создание пользовательских типов для проверки

Давайте возьмём идею использования системы типов Rust в качестве шага улучшения кода, чтобы убедиться, что у нас есть действительное значение и рассмотрим создание пользовательского типа для проверки. Вспомним игру угадывания из главы 2, в которой наш код просил пользователя угадать число между 1 и 100. Мы никогда не проверяли перед сравнением с нашим секретным номером, чем является предположение сделанное пользователем; мы только проверяли, что предположение было положительным. В этом случае последствия были не очень страшными: наши сообщения выводимые в консоль «Слишком много» или «Слишком мало» все равно будут правильными. Но было бы полезным улучшение, чтобы подталкивать пользователя к правильным догадкам и иметь различное поведение, когда пользователь угадывает число находящееся за пределами диапазона, в сравнении с тем, когда пользователь вводит, например, буквы вместо цифр.

Один из способов сделать таким образом - это разобрать значение предположения как тип `i32`, а не только как `u32`, чтобы разрешить потенциально отрицательные числа, а затем добавить проверку для нахождение числа в диапазоне, например, так:

```rust,ignore
loop {
    // --snip--

    let guess: i32 = match guess.trim().parse() {
        Ok(num) => num,
        Err(_) => continue,
    };

    if guess < 1 || guess > 100 {
        println!("The secret number will be between 1 and 100.");
        continue;
    }

    match guess.cmp(&secret_number) {
    // --snip--
}
```

Выражение `if` проверяет, находится ли наше значение вне диапазона, сообщает пользователю о проблеме и вызывает `continue`, чтобы опять начать следующую итерацию цикла и снова попросить ввести другое предположение. После выражения `if` мы можем продолжить сравнение значения `guess` с загаданным числом, зная что `guess` в диапазоне от 1 до 100.

Однако это не идеальное решение: если бы было абсолютно критично, чтобы программа работала только со значениями от 1 до 100 и имела много особенностей, связанных с этим требованием, то такая проверка в каждой функции была бы утомительной (и могла бы повлиять на производительность).

Вместо этого можно создать новый тип и поместить проверки в функцию создания экземпляр этого типа, не повторяя везде проверки. Таким образом будет безопасно использовать новый тип в сигнатурах и уверенно использовать получаемые значения в других функциях. Листинг 9-10 показывает один способ определить тип `Guess` , который будет только создавать экземпляр `Guess` , при условии что функция `new` получает значение от 1 до 100.

```rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess {
            value
        }
    }

    pub fn value(&self) -> i32 {
        self.value
    }
}
```

<span class="caption">Листинг 9-10. Тип <code>Guess</code> который будет создавать экземпляры только при значении между 1 и 100</span>

Сначала мы определяем структуру с именем `Guess` , которая имеет поле с именем `value` имеющее тип  `i32` . Здесь будет храниться число.

Затем мы реализуем ассоциированную функцию с названием `new` создающую экземпляры значений типа `Guess`. Функция `new`  определена с одним параметром с именем `value` типа `i32` и возвращает `Guess` . Код в теле функции `new` проверяет что значение `value` находится между 1 и 100. Если `value` не проходит эту проверку, мы вызываем `panic!` , который оповестит программиста её вызывающего о том, что у него есть ошибка, которую необходимо исправить, потому что создание `Guess` со значением `value` вне этого диапазона будет нарушать контракт, на который полагается `Guess::new` . Условия, в которых `Guess::new` паникует должна быть описана в документации к API; мы рассмотрим соглашения о документации, указывающие на возможность появления `panic!` в документации API, которую вы создадите в главе 14. Если `value` проходит проверку, мы создаём новый экземпляр `Guess` с его внутренним значением поля  `value` установленным из значения параметра `value` и возвращаем `Guess`.

Далее мы реализуем метод с названием `value`, который заимствует `self` , не имеет каких-либо других параметров и возвращает тип `i32`. Этот метод иногда называют *получатель* (getter), потому что его цель состоит в том, чтобы получить некоторые данные полей и вернуть их. Этот публичный метод является необходимым , поскольку `value` поля структуры `Guess`  является приватным. Важно, чтобы поле `value` было приватным, так что код использующий структуру `Guess` не имеет разрешения устанавливать напрямую `value`: код снаружи модуля *должен* использовать функцию `Guess::new` для создания экземпляра `Guess`, таким образом гарантируя, что у `Guess` нет возможности получить `value` не проверенное условиями в функции `Guess::new`.

Функция, которая имеет параметр или возвращает только числа от 1 до 100, может затем объявить в своей сигнатуре, что она принимает или возвращает `Guess` вместо типа `i32`, таким образом не будет необходимости делать дополнительные проверки в теле такой функции.

## Итоги

Функции обработки ошибок в Rust призваны помочь вам написать более надежный код. Макрос `panic!` сигнализирует, что ваша программа находится в состоянии, которое она не может обработать и позволяет сказать процессу прекратить выполнение, вместо попытки продолжить с недействительным или неверными значениями. Перечисление `Result` использует систему типов Rust, чтобы указать, что операции могут завершиться неудачей таким образом, чтобы ваш код мог восстановиться. Можно использовать `Result` , чтобы сообщить вызывающему коду, что он должен обрабатывать потенциальный успех или потенциальную неудачу. Используя `panic!` и `Result` в соответствующей ситуации, сделают ваш код более надёжным перед лицом неизбежных проблем.

Теперь, когда вы увидели полезные способы в которых стандартная библиотека использует обобщённые типы `Option` и `Result` , мы поговорим о том, как работают обобщённые типы и как вы можете использовать их в своём коде.
