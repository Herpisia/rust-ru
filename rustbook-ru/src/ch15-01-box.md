## Использование `Box<T>` для ссылки на данные в куче

Наиболее простой умный указатель - это *box*, чей тип записывается как `Box<T>`. Такие переменные позволяют хранить данные в куче, а не в стеке. То что остаётся в стеке является указателем на данные в куче. Обратитесь к Главе 4, чтобы рассмотреть разницу между стеком и кучей.

У Box нет проблем с производительностью, кроме как хранения данных в куче вместо стека. Но он также и не имеет множества дополнительных возможностей. Вы будете использовать их чаще всего в следующих ситуациях:

- Если у вас есть тип, размер которого не может быть известен во время компиляции и вы хотите использовать значение этого типа в контексте, который требует точного размера
- Когда у вас есть большой объем данных и вы хотите передать его во владение, но убедиться, что данные не будут скопированы, когда вы это сделаете
- Когда вы хотите иметь значение и вам важно только то, что это тип, который реализует конкретный типаж, а не является конкретный типом

Мы продемонстрируем первую ситуацию в разделе [«Включение рекурсивных типов с помощью Box»](#enabling-recursive-types-with-boxes)<comment></comment>. Во втором случае, передача владения на большой объем данных может занять много времени, потому что данные копируются через стек. Для повышения производительности в этой ситуации, мы можем хранить большое количество данных в куче с помощью Box указателя. Затем только небольшое количество данных указателя копируется в стеке, в то время как данные на которые он ссылается, остаются в одном месте кучи. Третий случай известный как *типаж объект* (trait object), а глава 17 посвящает целый раздел [«Использование типаж объектов, которые допускают значения разных типов»](ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types)<comment></comment> только к этой теме. Итак то что вы узнаете здесь, вы примените снова в Главе 17!

### Использование `Box<T>` для хранения данных в куче

Прежде чем мы обсудим этот вариант использования `Box<T>`, мы рассмотрим синтаксис и как взаимодействовать со значениями, хранящимися в `Box<T>`.

В листинге 15-1 показано, как использовать поле для хранения значения `i32` в куче:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```

<span class="caption">Листинг 15-1: Сохранение значения <code>i32</code> в куче с использованием box</span>

Мы определяем переменную `b`, чтобы иметь значение `Box`, которое указывает на значение `5`, которое выделяется в куче. Эта программа напечатает `b = 5`; в этом случае мы можем получить доступ к данным в поле, как если бы это были данные в стеке. Как и любое значение во владении, данная память будет освобождена, когда box выйдет из области действия, что происходит с `b` в конце `main`. Освобождение box памяти происходит (хранится в стеке) и тех данных, на которые он указывает (хранятся в куче).

Размещение единственного значения в куче не очень полезно, поэтому вы не будете часто использовать box таким способом сам по себе. Иметь единственное значение `i32` в стеке, где они хранятся по умолчанию подходит в большинстве ситуаций. Давайте рассмотрим случай, когда Box позволяет определять типы, которые были бы не разрешены, если бы у нас не было Box.

### Включение рекурсивных типов с помощью Boxes

Во время компиляции Rust должен знать, сколько места занимает тип. Некоторый тип, чей размер не может быть известен во время компиляции, является *рекурсивным типом* (recursive type), где значение может иметь в своём составе другое значение того же типа. По причине того, что это вложение значений может теоретически продолжаться бесконечно, Rust не знает, сколько пространства памяти необходимо для значений рекурсивного типа. Однако Box имеет известный размер, поэтому указывая Box в определении рекурсивного типа можно его получить.

Давайте рассмотрим *cons список* (cons - функция конструктор, создаёт объекты памяти, которые содержат два значения или указатели на значения), который является типом данных распространённым в языках программирования как пример рекурсивного типа. Тип "cons список", который мы определим является простым, за исключением рекурсии; поэтому концепции в примере с которым мы будем работать, будут полезны в любое время, когда вы попадаете более сложные ситуации, связанные с рекурсивными типами.

#### Больше информации о cons списке

*cons список* (cons list) - это структура данных, которая пришла из языка программирования Lisp и его диалектов. В Lisp, функция `cons` (сокращение от “construct function” функция-конструктор) создаёт новую пару используя два аргумента, один из которых значение и другой пара. Эти пары, содержащие внутри следующие пары, образуют список.

Концепция функции конструктора прошла свой путь и превратилась в более общий функциональный, программный жаргон: "to cons *х* onto *у*" неформально означает создание нового экземпляра контейнера, помещая элемент *х* в начале нового контейнера за которым следует контейнер *y*.

Каждый элемент в cons списке содержит два элемента: значение текущего элемента и следующий элемент. Последний элемент в списке содержит только значение называемое `Nil` без следующего элемента. Cons список создаётся путём рекурсивного вызова `cons` функции. Каноническое имя для обозначения базового случая рекурсии - `Nil`. Обратите внимание, что это не то же самое, что понятие “null” или “nil” из главы 6, которая является недействительным или отсутствующим значением.

Хотя функциональные языки программирования часто используют cons списки, этот список не является широко используемой структурой данных в Rust. Большую часть времени, когда есть список элементов в Rust, лучше использовать `Vec<T>`. Более сложные рекурсивные типы данных *являются* полезными в различных ситуациях, но начиная изучение с cons списка, мы можем исследовать, как box-ы позволяют определить рекурсивный тип данных без особого отвлечения.

Листинг 15-2 содержит объявление перечисления cons списка. Обратите внимание, что этот код не будет компилироваться, потому что тип `List` не имеет известного размера, который мы продемонстрируем.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
enum List {
    Cons(i32, List),
    Nil,
}
```

<span class="caption">Листинг 15-2: Первая попытка определить перечисление для представления структуры данных cons списка из значений <code>i32</code></span>

> Примечание: мы реализуем cons список, который для примера содержит только значения `i32`. Чтобы определить тип cons список для хранения значения любого типа, мы могли бы реализовать его, используя обобщённые типы, как обсуждалось в главе 10.

Использование типа `List` для хранения списка `1, 2, 3` будет выглядеть как код в листинге 15-3:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
```

<span class="caption">Листинг 15-3: Использование перечисления <code>List</code> для хранения списка <code>1, 2, 3</code></span>

Первое значение `Cons` содержит `1` а другое значение `List`. Это значение `List` является следующим значением `Cons`, которое содержит `2` и другое значение `List`. Это значение `List` является ещё один значением `Cons`, которое содержит `3` и значение `List`, которое наконец является `Nil`, не рекурсивным вариантом, который сигнализирует об окончании списка.

Если мы попытаемся скомпилировать код в листинге 15-3, мы получим ошибку, показанную в листинге 15-4:

```text
error[E0072]: recursive type `List` has infinite size
 --> src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ----- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to
  make `List` representable
```

<span class="caption">Листинг 15-3: Получаемая ошибка при попытке определить бесконечное рекурсивное перечисление</span>

Ошибка показывает, что этот тип "имеет бесконечный размер". Причина в том, что мы определили `List` с рекурсивным вариантом: он содержит другое значение самого себя. В результате Rust не может понять, сколько места ему нужно для хранения значения `List`. Давайте разберёмся, почему мы получаем эту ошибку. Во-первых, давайте посмотрим как Rust решает, сколько места ему нужно для хранения значения не рекурсивного типа.

#### Вычисление размера нерекурсивного типа

Вспомните перечисление `Message` определённое в листинге 6-2, когда обсуждали объявление enum  в главе 6:

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

Чтобы определить, сколько памяти выделяется для значения `Message`, Rust проходит каждый из вариантов, чтобы увидеть, какой вариант требует наибольшее количество памяти. Rust видит, что для `Message::Quit` не требуется места, `Message::Move` хватает места для хранения двух значений `i32` и т.д. Так как будет использоваться только один вариант, то наибольшее пространство, которое потребуется для значения `Message`, это пространство, которое потребуется для хранения самого большой из вариантов перечисления.

Сравните это с тем, что происходит, когда Rust пытается определить сколько места необходимо рекурсивному типу, такому как перечисление `List` в листинге 15-2. Компилятор запускается глядя на вариант `Cons`, который содержит значение типа `i32` и значение типа `List`. Следовательно, `Cons` нужно пространство, равное размеру `i32` плюс размер `List`. Чтобы выяснить, сколько памяти необходимо в типе `List`, компилятор смотрит на варианты, начиная с `Cons` варианта. Вариант `Cons` содержит значение типа `i32` и значение типа `List`, и этот процесс продолжается бесконечно, как показано на рисунке 15-1.

<img alt="An infinite Cons list" src="../../rustbook-en/src/img/trpl15-01.svg" class="center" style="width: 50%;">

<span class="caption">Рисунок 15-1: Бесконечный <code>List</code> состоящий из бесконечных <code>Cons</code> вариантов</span>

#### Использование `Box<T>` для получения рекурсивного типа с известным размером

Rust не может понять, сколько места выделить для типов определённых рекурсивно, поэтому компилятор выдаёт ошибку в листинге 15-4. Но ошибка включает в себя это полезное предложение:

```text
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to
  make `List` representable
```

В этом предложении "косвенность" означает, что вместо сохранения значения напрямую, мы изменим структуру данных для хранения косвенного значения, с помощью хранения указателя на значение.

Поскольку `Box<T>` является указателем, Rust всегда знает, сколько памяти нужно для `Box<T>`: размер указателя не изменяется в зависимости от количества данных на которые он указывает. Это означает, что мы можем поместить тип `Box<T>` в вариант перечисления `Cons` вместо прямого значения `List`. Поле `Box<T>` будет указывать на следующее значение `List`, которое будет в куче, а не внутри варианта `Cons`. Концептуально у нас все ещё есть список, созданный со списками, "содержащими" другие списки, но эта реализация теперь больше похожа на размещение элементов рядом друг с другом, а не внутри друг друга.

Мы можем изменить определение перечисления `List` в листинге 15-2 и использование `List` в листинге 15-3 к коду в листинге 15-5, который будет компилироваться:

<span class="filename">Файл: src/main.rs</span>

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
```

<span class="caption">Листинг 15-5: Определение <code>List</code>, который использует <code>Box<T></code>, чтобы иметь известный размер</span>

Варианту `Cons` понадобится размер `i32` плюс место для хранения данных указателя Box. Вариант `Nil` не хранит значений, поэтому ему нужно меньше места, чем варианту `Cons`. Теперь мы знаем, что любое значение `List` будет занимать размер `i32` плюс размер данных указателя Box. Используя Box, мы сломали бесконечную рекурсивную цепочку, так что компилятор может определить размер, необходимый для хранения значения `List`. На рисунке 15-2 показано как теперь выглядит вариант `Cons`.

<img alt="A finite Cons list" src="../../rustbook-en/src/img/trpl15-02.svg" class="center">

<span class="caption">Рисунок 15-2: <code>List</code>, размер которого не безграничен, потому что <code>Cons</code> содержит <code>Box</code></span>

Box-ы обеспечивают только косвенность и выделение в куче; у них нет других специальных возможностей, таких как те, которые мы увидим у других типов умных указателей. Они также не имеют накладных расходов для этих специальных возможностей, поэтому могут быть полезны в случаях похожих на cons список, где косвенность - единственная, нужная функциональность. Мы рассмотрим ещё больше вариантов использования типа Box в главе 17.

Тип `Box<T>` является умным указателем, потому что он реализует типаж `Deref`, что позволяет значениям `Box<T>` обрабатываться как ссылки. Когда значение `Box<T>` выходит из области видимости, то данные кучи на которые указывает Box очищаются, благодаря реализации типажа `Drop`. Давайте рассмотрим эти два типажа более подробно. Эти два типажа будут ещё более важными для функциональности, предоставляемой другими типами умных указателей, которые мы обсудим в остальной части этой главы.
