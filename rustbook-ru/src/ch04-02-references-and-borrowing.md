## Ссылочные переменные и заимствование

Основная проблематика в подходе с использованием кортежа в листинге 4-5 заключается в том, что мы должны вернуть `String` в вызывающую функцию, чтобы мы могли использовать `String` после вызова функции `calculate_length`, потому что `String` была перемещена в функцию`calculate_length`. Вместо этого мы можем предоставить ссылку на значение `String` *Ссылка* похожа на указатель в том смысле, что это адрес, по которому мы можем получить доступ к данным, хранящимся по этому адресу, принадлежащему какой-либо другой переменной. В отличие от указателя, ссылка гарантированно указывает на допустимое значение определённого типа. Вот как вы могли бы определить и использовать функцию `calculate_length` которая имеет ссылку на объект в качестве параметра вместо того, чтобы владеть значением:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-07-reference/src/main.rs:all}}
```

Во-первых, обратите внимание, что весь код кортежа в объявлении переменной и возвращаемое значение функции исчезли. Во-вторых, обратите внимание, что мы передаём `&s1` в `calculate_length` и в его определении мы берём `&String` а не `String`. Эти амперсанды представляют собой *ссылки*, и они позволяют вам ссылаться на некоторое значение, не принимая владение им. Рисунок 4-5 изображает эту концепцию.

 <img alt="&amp;String s pointing at String s1" src="img/trpl04-05.svg" class="">

<span class="caption">Картинка 4-5: Диаграмма для <code>&amp;String s</code>, указывающей на <code>String s1</code></span>

> Заметьте: Операцией обратной созданию ссылки, используя `&`, является операция *разыменования*, которая выполняется с помощью оператора разыменования `*`. Вы увидите использование этого оператора в Главе 8, и мы обсудим детали ещё в Главе 15.

Давайте подробнее рассмотрим механизм вызова функции:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-07-reference/src/main.rs:here}}
```

`&s1` позволяет нам создать ссылку, которая *ссылается* на значение `s1`, но не владеет им. Поскольку она не владеет значением, на которое она указывает, значение не будет удалено, когда ссылка перестанет использоваться.

Сигнатура функции использует `&` для индикации того, что тип параметра `s` является ссылкой. Добавим объясняющие комментарии:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-08-reference-with-annotations/src/main.rs:here}}
```

Область видимости, в которой `s` валидна, такая же, как и область видимости любого параметра функции, но значение, на которое указывает ссылка, не удаляется, когда `s` перестаёт использоваться, потому что `s` не является владельцем. Когда функции имеют ссылки в качестве параметров вместо фактических значений, нам не нужно возвращать значения, чтобы вернуть право собственности, потому что мы никогда не владели ими.

Мы называем действие создания ссылки *заимствованием*. Как и в реальной жизни, если человек чем-то владеет, вы можете это у него позаимствовать. Когда вы закончите, вы должны вернуть его. Вы им не владеете.

А что произойдёт, если попытаться изменить то, что было позаимствовано? Попробуйте код листинга 4-6. Предупреждаем, этот код не сработает!

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-06/src/main.rs}}
```

<span class="caption">Listing 4-6: Попытка модификации заимствованного значения</span>

Вот ошибка:

```console
{{#include ../listings/ch04-understanding-ownership/listing-04-06/output.txt}}
```

Ссылки, как и переменные, являются неизменяемыми по умолчанию. Нам не разрешено изменять что-то, на что у нас есть ссылка.

### Изменяемые ссылочные переменные

Мы можем исправить код из листинга 4-6, чтобы позволить нам изменять заимствованное значение с помощью небольших изменений, которые вместо ссылки используют *изменяемую ссылку*:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-09-fixes-listing-04-06/src/main.rs}}
```

Сначала мы делаем `s` изменяемой переменной. Затем мы создаём изменяемую ссылку с помощью `&mut s` при вызове функции `change` и обновляем сигнатуру функции, чтобы принять изменяемую ссылку с помощью `some_string: &mut String`. Это даёт понять, что функция `change` может изменять значение, которое она заимствует.

У изменяемых ссылок есть одно большое ограничение: вы можете иметь только одну изменяемую ссылку на определённый фрагмент данных одновременно. Этот код, который пытается создать две изменяемые ссылки на `s`, потерпит неудачу:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-10-multiple-mut-not-allowed/src/main.rs:here}}
```

Описание ошибки:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-10-multiple-mut-not-allowed/output.txt}}
```

Эта ошибка говорит о том, что этот код недействителен, потому что мы не можем заимствовать `s` как изменяемые более одного раза в один момент. Первое изменяемое заимствование находится в `r1` и должно длиться до тех пор, пока оно не будет использовано в `println!`, но между созданием этой изменяемой ссылки и её использованием мы попытались создать другую изменяемую ссылку в `r2`, которая заимствует те же данные, что и `r1`.

Ограничение, предотвращающее одновременное использование нескольких изменяемых ссылок на одни и те же данные, допускает изменение, но очень контролируемым образом. Это то, с чем борются новые Rustaceans, потому что большинство языков позволяют изменять значение, когда захотите. Преимущество этого ограничения заключается в том, что Rust может предотвратить гонки данных во время компиляции. *Гонка данных* похожа на состояние гонки и происходит, когда возникают следующие три сценария:

- два или больше указателей используют те же данные в одно и тоже время,
- минимум один указатель используется для записи данных,
- отсутствуют механизмы для синхронизации доступа к данным.

Гонки данных вызывают неопределённое поведение и их может быть сложно диагностировать и исправить, когда вы пытаетесь отследить их во время выполнения; Rust предотвращает эту проблему, отказываясь компилировать код с гонками данных!

Как всегда, мы можем использовать фигурные скобки для создания новой области видимости, позволяющей использовать несколько изменяемых ссылок, но не *одновременно*:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-11-muts-in-separate-scopes/src/main.rs:here}}
```

Rust применяет аналогичное правило для комбинирования изменяемых и неизменяемых ссылок. Этот код приводит к ошибке:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-12-immutable-and-mutable-not-allowed/src/main.rs:here}}
```

Ошибка:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-12-immutable-and-mutable-not-allowed/output.txt}}
```

Ух! У нас *также* не может быть изменяемой ссылки, пока у нас есть неизменяемая ссылка на то же значение. Пользователи неизменной ссылки не ожидают, что значение внезапно изменится! Однако разрешены множественные неизменяемые ссылки, потому что никто, кто просто читает данные, не может повлиять на чтение данных кем-либо другим.

Обратите внимание, что область действия ссылки начинается с того места, где она была введена, и продолжается до последнего использования этой ссылки. Например, этот код будет компилироваться, потому что последнее использование неизменяемых ссылок `println!`, происходит до того, как вводится изменяемая ссылка:

```rust,edition2018
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-13-reference-scope-ends/src/main.rs:here}}
```

Области неизменяемых ссылок `r1` и `r2` заканчиваются после `println!` где они использовались в последний раз, то есть до создания изменяемой ссылки `r3`. Эти области не пересекаются, поэтому этот код разрешён. Способность компилятора сообщить, что ссылка больше не используется в точке до конца области видимости, называется *нелексическим временем жизни* (сокращённо NLL), и вы можете прочитать об этом больше в [The Edition Guide][nll].

Не смотря на то, что ошибки заимствования могут иногда вызывать разочарование, помните, что компилятор Rust указывает про потенциальную проблему на ранних этапах (во время компиляции, а не во время выполнения) и показывает точно, где находится проблема. Так что вам не нужно отслеживать, почему ваши данные не соответствуют вашим ожиданиям.

### Недействительные ссылки

В языках с указателями весьма легко ошибочно создать недействительную, висячую *(dangling)* ссылку. Ссылку указывающую на участок памяти, который мог быть передан кому-то другому, путём освобождения некоторой памяти при сохранении указателя на эту память. Rust компилятор гарантирует, что ссылки никогда не станут недействительными: если у вас есть ссылка на какие-то данные, компилятор гарантирует, что эти данные не выйдут из области видимости прежде, чем из области видимости исчезнет ссылка.

Попытаемся смоделировать подобную, висячую ссылку, появление которой компилятор предотвратит:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-14-dangling-reference/src/main.rs}}
```

Здесь ошибка:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-14-dangling-reference/output.txt}}
```

Эта ошибка сообщает об ещё не освещённой нами возможности языка Rust: <em>времени жизни переменной (lifetime)</em>. Мы расскажем подробнее об этой возможности в Главе 10. Но если вы проигнорируете раздел ошибки который говорит о времени жизни, то все ещё будете способны найти ключ к тому, почему этот код является проблемным:

```text
this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
```

Давайте пристальней рассмотрим, что же происходит на каждой стадии работы кода функции `dangle`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-15-dangling-reference-annotated/src/main.rs:here}}
```

По причине того, что переменная `s` создана внутри функции `dangle`, то при завершении `dangle` содержимое памяти для `s` будет удалено из памяти. Но мы пытаемся вернуть ссылку на эту память. Это означает, что данная ссылка могла бы указывать на недействительную `String`. Это плохо! Rust не позволит нам этого сделать.

Решением является вернуть непосредственно `String`:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-16-no-dangle/src/main.rs:here}}
```

Это решение работает без проблем. Владение перемещено наружу и ничего не удаляется  из памяти.

### Правила работы с ссылками

Давайте повторим  все, что мы обсудили про ссылки:

- в один момент времени, может существовать *либо* одна изменяемая ссылочная переменная, *либо* любое количество неизменяемых ссылочных переменных,
- все ссылки должны быть действительными.

В следующей главе мы рассмотрим другой тип ссылочных переменных - срезы.

[nll]: https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/non-lexical-lifetimes.html
